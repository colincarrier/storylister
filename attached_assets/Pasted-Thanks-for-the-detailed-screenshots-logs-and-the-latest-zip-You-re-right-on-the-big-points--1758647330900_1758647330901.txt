Thanks for the detailed screenshots, logs, and the latest zip. Youâ€™re right on the big points:

* **First story** still isnâ€™t analyzed reliably.
* **Viewer chunks can be misâ€‘routed** when you move between stories.
* **Video autoâ€‘pause** feels botty.
* **Cache** isnâ€™t being reused (panel â€œrecountsâ€ on refresh).
* **Reactions** (â¤ï¸ğŸ‘ğŸ”¥ etc.) arenâ€™t captured or filterable.
* The **huge console spam** you saw earlier came from bad avatar URLs getting retried; weâ€™ll hardâ€‘guard that.

Below is a **small, surgical patchâ€‘set** that fixes thoseâ€”no overâ€‘engineering, and only touching the places that matter. It keeps the panel fully independent (no â€œportalâ€), plays nicely with Instagramâ€™s UI, and uses only data already delivered to your browser (no new API calls).

---

## 1) `content-backend.js` â€”  **first story**, **correct routing**, **natural pause**, **cache write**, **defaults**

> **Drop these additions/replacements in your file.** (Search the anchors in comments and replace the function bodies where indicated.)

```js
// ==== [A] TOP OF FILE: state + Settings (REPLACE these declarations) ====
const DEBUG = false;

const state = {
  injected: false,
  currentKey: null,          // stable key = location.pathname (works with and w/o numeric id)
  autoOpenInProgress: false,
  openedForKey: new Set(),   // prevent re-opening
  stopPagination: null,
  viewerStore: new Map(),    // Map<storyKey, Map<viewerKey, viewer>>
  mirrorTimer: null,
  idToKey: new Map(),        // Map<mediaId -> storyKey>
};

const Settings = {
  // Defaults that should â€œjust workâ€
  cache: { pro: false, autoOpen: true, pauseVideos: true, accountHandle: null },

  async load() {
    try {
      const data = await new Promise(r => chrome.storage?.sync?.get?.(null, r));
      if (data) Object.assign(this.cache, data);
    } catch (e) {
      // Fallback when extension context gets invalidated
      try {
        const raw = localStorage.getItem('sl_settings');
        if (raw) Object.assign(this.cache, JSON.parse(raw));
      } catch {}
    }
  },

  async save(patch) {
    Object.assign(this.cache, patch);
    try {
      await new Promise(r => chrome.storage?.sync?.set?.(patch, r));
    } catch (e) {
      // Persist anyway
      try { localStorage.setItem('sl_settings', JSON.stringify(this.cache)); } catch {}
    }
  }
};

// ==== [B] UTILITIES (ADD) ====
function getStorageKey() { return location.pathname; }  // first-story safe

function findSeenByButton() {
  return document.querySelector('a[href*="/seen_by/"]') ||
         Array.from(document.querySelectorAll('[role="button"],button'))
           .find(el => /^Seen by(\s+[0-9,]+)?$/i.test((el.textContent||'').trim())) || null;
}

async function waitForSeenByButton(timeout = 5000, interval = 150) {
  const start = Date.now();
  while (Date.now() - start < timeout) {
    const btn = findSeenByButton();
    if (btn) return btn;
    await new Promise(r => setTimeout(r, interval));
  }
  return null;
}

function findScrollableInDialog() {
  const dlg = document.querySelector('[role="dialog"][aria-modal="true"]');
  if (!dlg) return null;
  return dlg.querySelector('[style*="overflow-y"]') ||
         dlg.querySelector('[style*="overflow: hidden auto"]') ||
         Array.from(dlg.querySelectorAll('div')).find(el => el.scrollHeight > el.clientHeight + 40) ||
         dlg;
}

function getSeenByCount() {
  const link = document.querySelector('a[href*="/seen_by/"]');
  const txt = (link?.textContent || '').trim();
  const m = txt.match(/(\d[\d,]*)/);
  return m ? parseInt(m[1].replace(/,/g, ''), 10) : null;
}

// ==== [C] NATURAL PAUSE â€” pause only while the IG viewers dialog is open (REPLACE your pause code) ====
function pauseVideosWhileViewerOpen() {
  if (!Settings.cache.pauseVideos) return;
  const dlgOpen = !!document.querySelector('[role="dialog"][aria-modal="true"]');
  if (!dlgOpen) return; // don't auto-pause when the dialog isnâ€™t open

  setTimeout(() => {
    document.querySelectorAll('video').forEach(v => {
      if (v.dataset.userPlayed === '1') return; // respect manual play
      if (!v.paused && !v.dataset.slPaused) {
        try { v.pause(); v.dataset.slPaused = '1'; } catch {}
      }
    });
  }, 1200); // breaths like a human
}

function resumeAnyPausedVideos() {
  document.querySelectorAll('video[data-sl-paused="1"]').forEach(v => {
    try { v.play(); } catch {}
    delete v.dataset.slPaused;
  });
}
document.addEventListener('play', (e) => {
  if (e.target?.tagName === 'VIDEO') e.target.dataset.userPlayed = '1';
}, true);

// ==== [D] PAGINATION â€” simple + bounded (REPLACE your paginator) ====
function startPagination(scroller, maxMs = 6000) {
  const t0 = Date.now();
  let stopped = false;
  const tick = () => {
    if (stopped || !document.contains(scroller)) return;
    if (Date.now() - t0 > maxMs) return;

    const target = getSeenByCount();
    const currentMap = state.viewerStore.get(getStorageKey());
    const loaded = currentMap ? currentMap.size : 0;
    if (target && loaded >= target - 1) return; // allow Â±1

    scroller.scrollTop = scroller.scrollHeight;
    const nearBottom = scroller.scrollTop + scroller.clientHeight >= scroller.scrollHeight - 10;
    setTimeout(tick, nearBottom ? 450 : 250);
  };
  tick();
  return () => { stopped = true; };
}

// ==== [E] AUTO-OPEN â€” first story safe (REPLACE your open code) ====
async function autoOpenViewersOnceFor(key) {
  if (!Settings.cache.autoOpen) return;
  if (state.openedForKey.has(key)) return;
  const btn = await waitForSeenByButton(5000);
  if (!btn) return;
  state.openedForKey.add(key);
  try { btn.click(); } catch {}
  setTimeout(() => {
    const scroller = findScrollableInDialog();
    if (scroller) {
      if (state.stopPagination) state.stopPagination();
      state.stopPagination = startPagination(scroller);
    }
  }, 350);
}

// ==== [F] MIRROR TO CACHE â€” key = pathname; write debounced (REPLACE your mirror fn) ====
function mirrorToLocalStorageDebounced(key) {
  if (state.mirrorTimer) return;
  state.mirrorTimer = setTimeout(() => {
    state.mirrorTimer = null;
    const map = state.viewerStore.get(key);
    if (!map || map.size === 0) return;

    const store = JSON.parse(localStorage.getItem('panel_story_store') || '{}');
    store[key] = { viewers: Array.from(map.entries()), fetchedAt: Date.now() };

    // Also store aliases for mediaIds that map to this key (prevents mis-routing on refresh)
    const aliases = {};
    for (const [mid, k] of state.idToKey.entries()) if (k === key) aliases[mid] = k;
    store.__aliases = Object.assign(store.__aliases || {}, aliases);

    localStorage.setItem('panel_story_store', JSON.stringify(store));
    window.dispatchEvent(new CustomEvent('storylister:data_updated', { detail: { storyId: key } }));
  }, 300);
}

// ==== [G] MESSAGE BRIDGE â€” correct routing + dedupe (REPLACE your message handler) ====
window.addEventListener('message', (evt) => {
  if (evt.source !== window || evt.origin !== location.origin) return;
  const msg = evt.data;
  if (!msg || msg.type !== 'STORYLISTER_VIEWERS_CHUNK') return;

  const { mediaId, viewers } = msg.data || {};
  if (!mediaId || !Array.isArray(viewers)) return;

  const activeKey = state.currentKey || getStorageKey();
  if (!state.idToKey.has(mediaId)) state.idToKey.set(mediaId, activeKey);
  const key = state.idToKey.get(mediaId);

  if (!state.viewerStore.has(key)) state.viewerStore.set(key, new Map());
  const map = state.viewerStore.get(key);

  viewers.forEach((v, idx) => {
    // dedupe by username (lowercased) or id
    const viewerKey = (v.username ? String(v.username).toLowerCase() : null) || String(v.id || idx);
    const prev = map.get(viewerKey) || {};
    map.set(viewerKey, { ...prev, ...v });
  });

  mirrorToLocalStorageDebounced(key);
});

// ==== [H] MAIN OBSERVER â€” first story, inject, pause only when dialog open (REPLACE your observer callback) ====
const onDOMChange = (() => {
  let lastKey = null;
  return async () => {
    // gate: only on your own story (Seen by must eventually exist)
    const onStories = location.pathname.startsWith('/stories/');
    if (!onStories) {
      window.dispatchEvent(new CustomEvent('storylister:hide_panel'));
      resumeAnyPausedVideos();
      return;
    }

    window.dispatchEvent(new CustomEvent('storylister:show_panel'));
    // if injection fails because context reloaded, we still keep running
    if (!state.injected) {
      try {
        const s = document.createElement('script');
        // inline the payload to avoid getURL() errors on context reload
        s.textContent = `(${injectedFunction.toString()})();`;
        document.documentElement.appendChild(s);
        s.remove();
        state.injected = true;
      } catch {}
    }

    const key = getStorageKey();
    if (key !== lastKey) {
      // story changed
      if (state.stopPagination) state.stopPagination();
      lastKey = state.currentKey = key;
      autoOpenViewersOnceFor(key);
    }

    // pause only while viewers dialog is open
    pauseVideosWhileViewerOpen();
  };
})();

new MutationObserver(() => onDOMChange()).observe(document.documentElement || document.body, { childList: true, subtree: true });
onDOMChange();
```

> **Note**: `injectedFunction` above is defined in the next section so we can inline it safely to avoid `chrome.runtime.getURL` failures when the extension is reloaded in the background.

---

## 2) `injected.js` â€” **robust JSON filter, reaction extraction, safe avatar URL, mediaId**

> Replace file contents with the function below and let `content-backend.js` inline it (see \[H] above).

```js
function injectedFunction() {
  'use strict';
  if (window.__storylisterInjected__) return;
  window.__storylisterInjected__ = true;

  const origFetch = window.fetch;
  window.fetch = async function(...args) {
    const res = await origFetch.apply(this, args);

    try {
      const url = String(args?.[0] || '');
      // Only JSON
      const ct = res.headers?.get('content-type') || '';
      if (!/json/i.test(ct)) return res;

      const relevant = url.includes('/api/') || url.includes('/graphql') || /viewer|viewers|story|reel|seen/i.test(url);
      if (!relevant) return res;

      const clone = res.clone();
      clone.json().then(data => {
        if (!data) return;

        // Collect viewers from known shapes
        let viewers = null;
        if (Array.isArray(data.users)) viewers = data.users;
        else if (Array.isArray(data.viewers)) viewers = data.viewers;
        else if (data?.data?.xdt_api__v1__media__story_viewers?.viewers) viewers = data.data.xdt_api__v1__media__story_viewers.viewers;
        else if (data?.data?.media?.story_viewers?.edges) viewers = data.data.media.story_viewers.edges.map(e => e.node || e.user || e);
        else if (data?.data?.xdt_api__v1__stories__viewers__connection__edge?.edges) viewers = data.data.xdt_api__v1__stories__viewers__connection__edge.edges.map(e => e.node || e);

        if (!viewers || viewers.length === 0) return;

        // Media id: prefer payload, then URL id
        const pathId = location.pathname.match(/\/stories\/[^/]+\/(\d+)/)?.[1];
        const graphId = data?.media_id || data?.data?.media?.id || data?.data?.reel?.id;
        const mediaId = String(graphId || pathId || Date.now());

        const normalized = viewers.map((v, idx) => normalizeViewer(v, idx));

        window.postMessage({
          type: 'STORYLISTER_VIEWERS_CHUNK',
          data: {
            mediaId,
            viewers: normalized,
            totalCount: data.user_count || data.total_viewer_count || normalized.length
          }
        }, '*');
      }).catch(() => {});
    } catch {}
    return res;
  };

  // (Optional) XHR backup for older endpoints
  const XHR = window.XMLHttpRequest;
  if (XHR) {
    const P = XHR.prototype, _open = P.open, _send = P.send;
    P.open = function(method, url, ...rest) { this.__slUrl = url; return _open.call(this, method, url, ...rest); };
    P.send = function(...args) {
      const url = this.__slUrl || '';
      if (/story_viewers|list_reel_media_viewer|api\/v1\//.test(url)) {
        this.addEventListener('load', function() {
          try {
            const data = JSON.parse(this.responseText);
            const users = Array.isArray(data?.users) ? data.users : (Array.isArray(data?.viewers) ? data.viewers : null);
            if (!users) return;

            const pathId = location.pathname.match(/\/stories\/[^/]+\/(\d+)/)?.[1];
            const mediaId = String(data.media_id || pathId || Date.now());
            const normalized = users.map((u, idx) => normalizeViewer(u, idx));

            window.postMessage({
              type: 'STORYLISTER_VIEWERS_CHUNK',
              data: { mediaId, viewers: normalized, totalCount: data.user_count || normalized.length }
            }, '*');
          } catch {}
        });
      }
      return _send.apply(this, args);
    };
  }

  function normalizeViewer(v, idx) {
    const u = v?.user || v?.node?.user || v?.node || v;

    // Robust profile pic: accept only absolute http(s) URLs
    let pic = u?.profile_pic_url || u?.profile_pic_url_hd || u?.profile_picture_url || '';
    if (typeof pic !== 'string' || !/^https?:\/\//i.test(pic)) pic = '';

    // Reactions from known shapes; likes -> â¤ï¸
    const reaction =
      v?.reaction?.emoji ||
      v?.story_reaction?.emoji ||
      v?.latest_reaction?.emoji ||
      (v?.has_liked ? 'â¤ï¸' : null);

    return {
      id: String(u?.id || u?.pk || u?.pk_id || u?.username || idx),
      username: u?.username || '',
      full_name: u?.full_name || u?.fullname || u?.name || '',
      profile_pic_url: pic,
      is_verified: !!(u?.is_verified || u?.blue_verified || u?.is_verified_badge || u?.verified),
      followed_by_viewer: !!(u?.followed_by_viewer || u?.is_following),
      follows_viewer: !!(u?.follows_viewer || u?.is_follower),
      reaction: reaction || null,
      originalIndex: idx,
      viewedAt: v?.timestamp || v?.viewed_at || Date.now()
    };
  }
}
```

> This version **never** touches nonâ€‘JSON responses, so we wonâ€™t spam the console by accidentally trying to parse CSS/HTML. It also **guards avatar URLs** so malformed links in cache canâ€™t spin your network. (If you ever saw the massive `ERR_NAME_NOT_RESOLVED`, clear the old cache **once**: `localStorage.removeItem('panel_story_store')`.)

---

## 3) `content.js` â€” **â€œâ¤ï¸ Reactsâ€ filter + badge + loading cache without recounting**

Minimal UI hooks (no big refactor):

```js
// ==== [1] Insert the chip (LEFT of "Following") once, after panel is built ====
(function addReactsChip() {
  const bar = document.querySelector('#storylister-right-rail .sl-filter-chips');
  if (!bar || bar.querySelector('.sl-chip-reacts')) return;
  const btn = document.createElement('button');
  btn.className = 'sl-chip sl-chip-reacts';
  btn.type = 'button';
  btn.textContent = 'â¤ï¸ Reacts';
  btn.addEventListener('click', () => {
    window.__slFilterMode = window.__slFilterMode === 'reacts' ? 'all' : 'reacts';
    renderViewersFromCache(); // your existing render; see hook below
  });
  bar.prepend(btn);
})();

// ==== [2] Load/Merge from cache by pathname (no recount) ====
function loadCacheMapForCurrent() {
  const key = location.pathname;
  try {
    const store = JSON.parse(localStorage.getItem('panel_story_store') || '{}');
    const raw = store[key];
    if (!raw || !Array.isArray(raw.viewers)) return new Map();
    return new Map(raw.viewers); // Map<viewerKey, viewer>
  } catch { return new Map(); }
}

// ==== [3] Render hook that honors filter & â€œnewâ€ badges (call this in your existing render pipeline) ====
function renderViewersFromCache() {
  const map = loadCacheMapForCurrent();
  const all = Array.from(map.values());

  // â€œReactsâ€ filter
  const mode = window.__slFilterMode || 'all';
  const list = (mode === 'reacts') ? all.filter(v => !!v.reaction) : all;

  // Update counters
  const verified = list.filter(v => v.is_verified).length;
  const viewersCountEl = document.querySelector('#sl-count-viewers');
  const verifiedCountEl = document.querySelector('#sl-count-verified');
  if (viewersCountEl) viewersCountEl.textContent = map.size;
  if (verifiedCountEl) verifiedCountEl.textContent = verified;

  // Render each row (adapt to your existing template function)
  // Add small reaction bubble and â€œNEWâ€ badge if v._new
  // ...
}

// ==== [4] Re-render when backend mirrors ====
window.addEventListener('storylister:data_updated', () => renderViewersFromCache());

// First pass
renderViewersFromCache();
```

And **CSS tweak** for the reaction bubble and max height (if you donâ€™t already have it):

```css
/* Make the results area scroll without growing past the viewport */
#storylister-right-rail .storylister-panel { max-height: calc(100vh - 24px) !important; display:flex; flex-direction:column; }
#storylister-right-rail .storylister-results { flex:1; overflow-y:auto; min-height:0; }

/* Tiny reaction marker */
.sl-reaction { font-size: 12px; margin-left: 6px; }
.sl-badge-new { font-size: 11px; padding: 2px 6px; border-radius: 8px; background: #e9d5ff; color:#6b21a8; margin-left:8px; }
```

> **Where do â€œfollowers / followingâ€ come from?** We only surface the flags already included in Instagramâ€™s viewer payloads (`followed_by_viewer`, `follows_viewer`, or `friendship_status` inside XHR). **No extra calls.**

---

## 4) Why this fixes your specific symptoms

* **First story never loads:** we now **wait** for the *Seen by* button and only then autoâ€‘open/paginate. Key = `location.pathname`, so itâ€™s valid with or without an ID.
* **Over/under count & stale story mixing:** every network **chunk is mapped** via `mediaId -> storyKey` (`idToKey`). Chunks from old story canâ€™t increment the new one.
* **Autoâ€‘pause too aggressive:** we only pause **while the IG viewer dialog is actually open**, after a humanâ€‘ish delay, and we respect user play.
* **Cache reuse:** backend mirrors to `panel_story_store[key]` (where `key = pathname`) and the UI renders directly from that **Map**, so refresh/back doesnâ€™t recount.
* **Reactions:** extracted in `injected.js` and available as `viewer.reaction`; the **â€œâ¤ï¸ Reactsâ€** chip filters to those with a reaction.
* **Avatar/profile pics not loading & console storms:** we accept **only absolute http(s)** profile\_pic URLs and fall back to your initials SVG. If you had old bad URLs, run **once** in DevTools:
  `localStorage.removeItem('panel_story_store')`.

---

## 5) Quick validation checklist (30 seconds)

1. On your storyâ€™s first slide, open DevTools â†’ Console and run:

```js
!!document.querySelector('a[href*="/seen_by/"]') || 'waiting...'
```

Within \~1â€“3s this becomes `true`, the dialog opens, and the list paginates once.

2. Watch the **Viewers** number in the panel match Instagramâ€™s â€œSeen by Nâ€ (Â±1 is normal due to IG count rounding).

3. Click **â¤ï¸ Reacts** â†’ list shows only rows with a reaction bubble (e.g., â¤ï¸ ğŸ‘ ğŸ”¥).

4. Refresh the tab â†’ list **renders instantly** from cache; it does **not** recount from scratch.

5. Start playing the story â†’ it **keeps playing** unless the IG viewer dialog is open.

---

## 6) Oneâ€‘time cleanup (if you saw massive network errors)

* In the story tab console:
  `localStorage.removeItem('panel_story_store')`
  (removes bad cached avatar URLs from older runs).
* Ensure any debug logs in your UI are off.

---

If you want, I can also give you the tiny **UI row template** patch to show the reaction bubble and a `NEW` badge (based on â€œfirst time seen this sessionâ€). But the backend changes above are the keys that unblock (1) firstâ€‘story capture, (2) correct routing, (3) sane pause, and (4) durable cacheâ€”and theyâ€™re compact enough to paste in asâ€‘is.
