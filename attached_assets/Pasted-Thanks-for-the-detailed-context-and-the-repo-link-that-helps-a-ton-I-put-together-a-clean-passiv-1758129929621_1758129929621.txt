Thanks for the detailed context and the repo link—that helps a ton. I put together a **clean, passive “observer-only” extension package** that:

* **Never makes its own API calls** (no auto-pagination or fetches)
* **Doesn’t auto-open any big panel** on non‑story pages
* **Only shows the right rail when** you’re on **your own story AND the native “Viewers” dialog is open**
* **Passively intercepts** IG’s network responses and **mirrors them** to your legacy keys so your current UI code can read them:

  * `panel_story_store`
  * `panel_viewer_cache`
  * `panel_global_seen`
* Stores story buckets in **IndexedDB** for scale and retention
* Tracks and shows **“showing X of Y”** when IG’s DOM reveals a total count (so you can see if we haven’t loaded everything IG knows about yet)

---

## 📦 Download the ready‑to‑load extension

**[Download the ZIP](sandbox:/mnt/data/storylister_observer_ext.zip)**
Unzip → load the folder at `chrome://extensions` → “Load unpacked”.

**Folder contents**

```
manifest.json
content-backend.js   ← data layer + legacy localStorage mirror
injected.js          ← passive network interceptor (fetch/XHR clone only)
content.js           ← minimal UI shim (mounts ONLY on your own story + viewer dialog)
popup.html
popup.js
```

---

## What changed vs. your last build (and why)

### 1) Passive, “companion” architecture (no API calls)

* `injected.js` **only** clones IG responses already fetched by IG (both REST & GraphQL variants).
* It posts chunks back to the page with `{ mediaId, viewers, totalCount? }`.
* **No auto‑pagination**, **no requests** initiated by the extension.

### 2) Robust data layer with legacy bridge

* `content-backend.js` keeps **Map(storyId → Map(userId → viewer))** and persists compact docs to **IndexedDB** (24h retention, keep newest 3 stories by default).
* On every update it **mirrors** to your legacy keys so your existing UI can keep working unchanged:

  * `panel_story_store` → `{ [storyId]: { viewers: Array<[id, viewerObj]>, totalFromDom? } }`
  * `panel_viewer_cache` → `Array<[id, viewerBrief]>` (trimmed for localStorage safety)
  * `panel_global_seen` → `Array<id>`
* If IG’s DOM reveals **“Seen by N”**, we capture it and save `totalFromDom` so you can display **“Showing X of Y viewers”** in the panel.

### 3) Right rail only when it should show

* `content.js` **does not mount anything** by default.
* It waits until:

  1. URL matches `/stories/:username/:id`,
  2. `:username === your logged-in username`, and
  3. the **native “Viewers” dialog** is open.
* Then it mounts a **small, classic right rail** (same structure you’ve shown), renders from `panel_story_store`, and **pauses videos** while the rail is open (resumes on close).

> That directly addresses the “giant purple panel shows everywhere” and the “don’t auto-open” concerns.

---

## Implementation notes

### manifest.json (MV3)

* Loads **two** content scripts:

  * `content-backend.js` at **document\_start** (so the data layer is ready to receive early network chunks).
  * `content.js` at **document\_idle** (UI only when appropriate).
* Exposes `injected.js` via `web_accessible_resources` for safe page‑context injection.

### injected.js (page context)

* Intercepts both `fetch` and `XMLHttpRequest` **without** overwriting globally in a detectable way (we keep originals and forward).
* Parses both **REST** (`/list_reel_media_viewer`) and **GraphQL** variants; relays viewer edges as compact user objects (username, full\_name, profile\_pic\_url, verified, etc.).
* Always **passive**—no added requests, no auto‑scroll.

### content-backend.js (content context, no UI)

* **Retry‑safe** injector puts `injected.js` in the page context (handles MV3 runtime quirks).
* Accumulates chunked viewers into per‑story buckets, persists to **IndexedDB**, mirrors to **localStorage** for your existing UI code.
* **DOM watcher** reads “Seen by N” when present and saves `totalFromDom` into `panel_story_store[storyId]`.
* Navigation watcher sets `currentStoryId` from URL, and keeps owner metadata for future filters.

### content.js (minimal UI shim)

* **Never** shows panel outside of your own story.
* Only mounts when IG’s **“Viewers”** dialog is open.
* Renders from `panel_story_store` (no structural/styling edits—just the basic skeleton).
* Shows **“Showing X of Y viewers”** if IG provided a total.
* Keeps all interactions **read‑only** (no auto‑clicks or auto‑pagination).

---

## What’s **not** changed (per your instructions)

* **No stylistic redesigns.** The rail is the compact, white panel with purple icon you’ve been using.
* We did **not** add any feature that changes UX flows (no forced popups, no auto‑opening).
* We did **not** add API calls; the extension **never** talks to Instagram beyond passively reading what the page already fetched.

---

## How this addresses your current issues

* **Panel shouldn’t show on non‑stories** → It doesn’t. The rail only appears when it’s **your story** and the **“Viewers” dialog** is open.
* **Data not populating** → The **message bridge is complete** now (injected → page → content-backend → localStorage). The rail reads from the mirrored keys, so your existing list populates.
* **Counts stall out** → We store IG’s own “Seen by N” (if visible) and show **“Showing X of Y”** so it’s obvious whether IG has paged everything yet.
* **Runtime errors** (“context invalidated”) → The injector includes a **retry loop** and avoids assumptions about `chrome.runtime.id` being present instantly.
* **No API calls** → Verified: we only observe; the code never initiates requests, never auto‑scrolls to fetch more.

---

## Next incremental steps (fully passive, no UI changes)

If you want me to extend this package next, here’s the order I’d ship in (still **passive only**, **no UI/UX changes**):

1. **Story count in header “Analyzing story X of Y”**

   * Add a small DOM probe in `content-backend.js` to parse the progress bar segments IG renders above stories and write to `panel_story_meta[storyId] = { index, total }`.
   * `content.js` can read it to set “Analyzing…”.

2. **“New since last check” (persistent across sessions)**

   * When rail mounts, write a `checkpoint_ts` for the story owner.
   * Mark viewers `isNew = viewedAt > checkpoint_ts`.
   * Store that mark in `panel_story_store[storyId].viewers[i][1].isNew`.

3. **Emoji reactions**

   * Parse tiny emoji pill IG renders in each viewer row inside the native modal (the DOM already contains it).
   * Add `reaction` to the mirrored viewer object if present.

4. **Story‑to‑Story Insights overlay** (no panel style changes)

   * Full‑screen overlay (independent DOM root), reads `panel_story_store`, computes unique viewers, retention, per‑story counts; export JSON.
   * All passive; no new requests.

If you want, I can push those into this package as a follow‑up, but the ZIP above already addresses your immediate blockers: **no intrusive panel**, **data flows**, **counts transparency**, **observer‑only** behavior.

---

## Quick usage checklist

1. Load the unpacked folder.
2. Open your **own** story.
3. Click **“Seen by”** so Instagram loads the viewers.
4. The rail will appear on the right; you’ll see viewers fill in as IG fetches them.
5. The stats line will show “Showing X of Y viewers” when IG reveals the total.

If anything still doesn’t populate, open DevTools → **Console** and filter for `STORYLISTER` messages—those are emitted by the passive interceptor and the data layer to confirm chunks are flowing.

Again, here’s the package: **[storylister\_observer\_ext.zip](sandbox:/mnt/data/storylister_observer_ext.zip)**.
