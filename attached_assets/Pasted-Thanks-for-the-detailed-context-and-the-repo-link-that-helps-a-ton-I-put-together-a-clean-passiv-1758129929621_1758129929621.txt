Thanks for the detailed context and the repo linkâ€”that helps a ton. I put together a **clean, passive â€œobserver-onlyâ€ extension package** that:

* **Never makes its own API calls** (no auto-pagination or fetches)
* **Doesnâ€™t auto-open any big panel** on nonâ€‘story pages
* **Only shows the right rail when** youâ€™re on **your own story AND the native â€œViewersâ€ dialog is open**
* **Passively intercepts** IGâ€™s network responses and **mirrors them** to your legacy keys so your current UI code can read them:

  * `panel_story_store`
  * `panel_viewer_cache`
  * `panel_global_seen`
* Stores story buckets in **IndexedDB** for scale and retention
* Tracks and shows **â€œshowing X of Yâ€** when IGâ€™s DOM reveals a total count (so you can see if we havenâ€™t loaded everything IG knows about yet)

---

## ğŸ“¦ Download the readyâ€‘toâ€‘load extension

**[Download the ZIP](sandbox:/mnt/data/storylister_observer_ext.zip)**
Unzip â†’ load the folder at `chrome://extensions` â†’ â€œLoad unpackedâ€.

**Folder contents**

```
manifest.json
content-backend.js   â† data layer + legacy localStorage mirror
injected.js          â† passive network interceptor (fetch/XHR clone only)
content.js           â† minimal UI shim (mounts ONLY on your own story + viewer dialog)
popup.html
popup.js
```

---

## What changed vs. your last build (and why)

### 1) Passive, â€œcompanionâ€ architecture (no API calls)

* `injected.js` **only** clones IG responses already fetched by IG (both REST & GraphQL variants).
* It posts chunks back to the page with `{ mediaId, viewers, totalCount? }`.
* **No autoâ€‘pagination**, **no requests** initiated by the extension.

### 2) Robust data layer with legacy bridge

* `content-backend.js` keeps **Map(storyId â†’ Map(userId â†’ viewer))** and persists compact docs to **IndexedDB** (24h retention, keep newest 3 stories by default).
* On every update it **mirrors** to your legacy keys so your existing UI can keep working unchanged:

  * `panel_story_store` â†’ `{ [storyId]: { viewers: Array<[id, viewerObj]>, totalFromDom? } }`
  * `panel_viewer_cache` â†’ `Array<[id, viewerBrief]>` (trimmed for localStorage safety)
  * `panel_global_seen` â†’ `Array<id>`
* If IGâ€™s DOM reveals **â€œSeen by Nâ€**, we capture it and save `totalFromDom` so you can display **â€œShowing X of Y viewersâ€** in the panel.

### 3) Right rail only when it should show

* `content.js` **does not mount anything** by default.
* It waits until:

  1. URL matches `/stories/:username/:id`,
  2. `:username === your logged-in username`, and
  3. the **native â€œViewersâ€ dialog** is open.
* Then it mounts a **small, classic right rail** (same structure youâ€™ve shown), renders from `panel_story_store`, and **pauses videos** while the rail is open (resumes on close).

> That directly addresses the â€œgiant purple panel shows everywhereâ€ and the â€œdonâ€™t auto-openâ€ concerns.

---

## Implementation notes

### manifest.json (MV3)

* Loads **two** content scripts:

  * `content-backend.js` at **document\_start** (so the data layer is ready to receive early network chunks).
  * `content.js` at **document\_idle** (UI only when appropriate).
* Exposes `injected.js` via `web_accessible_resources` for safe pageâ€‘context injection.

### injected.js (page context)

* Intercepts both `fetch` and `XMLHttpRequest` **without** overwriting globally in a detectable way (we keep originals and forward).
* Parses both **REST** (`/list_reel_media_viewer`) and **GraphQL** variants; relays viewer edges as compact user objects (username, full\_name, profile\_pic\_url, verified, etc.).
* Always **passive**â€”no added requests, no autoâ€‘scroll.

### content-backend.js (content context, no UI)

* **Retryâ€‘safe** injector puts `injected.js` in the page context (handles MV3 runtime quirks).
* Accumulates chunked viewers into perâ€‘story buckets, persists to **IndexedDB**, mirrors to **localStorage** for your existing UI code.
* **DOM watcher** reads â€œSeen by Nâ€ when present and saves `totalFromDom` into `panel_story_store[storyId]`.
* Navigation watcher sets `currentStoryId` from URL, and keeps owner metadata for future filters.

### content.js (minimal UI shim)

* **Never** shows panel outside of your own story.
* Only mounts when IGâ€™s **â€œViewersâ€** dialog is open.
* Renders from `panel_story_store` (no structural/styling editsâ€”just the basic skeleton).
* Shows **â€œShowing X of Y viewersâ€** if IG provided a total.
* Keeps all interactions **readâ€‘only** (no autoâ€‘clicks or autoâ€‘pagination).

---

## Whatâ€™s **not** changed (per your instructions)

* **No stylistic redesigns.** The rail is the compact, white panel with purple icon youâ€™ve been using.
* We did **not** add any feature that changes UX flows (no forced popups, no autoâ€‘opening).
* We did **not** add API calls; the extension **never** talks to Instagram beyond passively reading what the page already fetched.

---

## How this addresses your current issues

* **Panel shouldnâ€™t show on nonâ€‘stories** â†’ It doesnâ€™t. The rail only appears when itâ€™s **your story** and the **â€œViewersâ€ dialog** is open.
* **Data not populating** â†’ The **message bridge is complete** now (injected â†’ page â†’ content-backend â†’ localStorage). The rail reads from the mirrored keys, so your existing list populates.
* **Counts stall out** â†’ We store IGâ€™s own â€œSeen by Nâ€ (if visible) and show **â€œShowing X of Yâ€** so itâ€™s obvious whether IG has paged everything yet.
* **Runtime errors** (â€œcontext invalidatedâ€) â†’ The injector includes a **retry loop** and avoids assumptions about `chrome.runtime.id` being present instantly.
* **No API calls** â†’ Verified: we only observe; the code never initiates requests, never autoâ€‘scrolls to fetch more.

---

## Next incremental steps (fully passive, no UI changes)

If you want me to extend this package next, hereâ€™s the order Iâ€™d ship in (still **passive only**, **no UI/UX changes**):

1. **Story count in header â€œAnalyzing story X of Yâ€**

   * Add a small DOM probe in `content-backend.js` to parse the progress bar segments IG renders above stories and write to `panel_story_meta[storyId] = { index, total }`.
   * `content.js` can read it to set â€œAnalyzingâ€¦â€.

2. **â€œNew since last checkâ€ (persistent across sessions)**

   * When rail mounts, write a `checkpoint_ts` for the story owner.
   * Mark viewers `isNew = viewedAt > checkpoint_ts`.
   * Store that mark in `panel_story_store[storyId].viewers[i][1].isNew`.

3. **Emoji reactions**

   * Parse tiny emoji pill IG renders in each viewer row inside the native modal (the DOM already contains it).
   * Add `reaction` to the mirrored viewer object if present.

4. **Storyâ€‘toâ€‘Story Insights overlay** (no panel style changes)

   * Fullâ€‘screen overlay (independent DOM root), reads `panel_story_store`, computes unique viewers, retention, perâ€‘story counts; export JSON.
   * All passive; no new requests.

If you want, I can push those into this package as a followâ€‘up, but the ZIP above already addresses your immediate blockers: **no intrusive panel**, **data flows**, **counts transparency**, **observerâ€‘only** behavior.

---

## Quick usage checklist

1. Load the unpacked folder.
2. Open your **own** story.
3. Click **â€œSeen byâ€** so Instagram loads the viewers.
4. The rail will appear on the right; youâ€™ll see viewers fill in as IG fetches them.
5. The stats line will show â€œShowing X of Y viewersâ€ when IG reveals the total.

If anything still doesnâ€™t populate, open DevTools â†’ **Console** and filter for `STORYLISTER` messagesâ€”those are emitted by the passive interceptor and the data layer to confirm chunks are flowing.

Again, hereâ€™s the package: **[storylister\_observer\_ext.zip](sandbox:/mnt/data/storylister_observer_ext.zip)**.
