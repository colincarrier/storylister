You’re right—the media (story) ID isn’t sprayed everywhere, but it **is** in a few dependable places that we can key off even when the URL doesn’t show it. Below is a practical map of where to find it on the current web UI and a drop‑in `getMediaIdFromDOM()` that pulls from those places in a safe order.

---

## Where the story ID reliably appears

1. **In the “Seen by” link** (your own story only)
   Selector: `a[href*="/seen_by/"]`
   The `href` is of the form:
   `/stories/<owner>/<MEDIA_ID>/seen_by/` → extract the digits.

2. **In `<link rel="alternate">` tags** (present on both your story and others’ + share links)
   Selector: `link[rel="alternate"][href*="/stories/"]`
   There are multiple hreflang variants. Each `href` contains `.../stories/<owner>/<MEDIA_ID>/...`.

3. **In app deep-link `<meta>` tags** (mobile app handoff)
   Selector: `meta[property^="al:"][content*="/stories/"]`
   The `content` value includes `.../stories/<owner>/<MEDIA_ID>/...`.

4. **Inside the base64 bootstrap script the page loads**
   Selector: `script[src^="data:text/javascript;base64,"]`
   If you `atob()` that `src`, you’ll see JSON blobs with story items, e.g.
   `"item":{"id":"3730474024150742664", ...}` or `"id":"<MEDIA_ID>"` near story fields.
   Decoding this is cheap and avoids extra network calls (we’re not fetching anything cross‑origin).

5. **(Best‑case fast path)** In the URL itself
   `/stories/<owner>/<MEDIA_ID>/...`

---

## Drop‑in code (content‑backend.js)

Replace your existing media‑id helper with this **robust** version. It tries the fast paths first and only scans the heavier sources when needed.

```js
function getStoryOwnerFromURL() {
  const m = location.pathname.match(/\/stories\/([^/]+)/);
  return m ? m[1] : null;
}

function matchIdFromText(text, owner) {
  if (!text) return null;

  // Prefer matches scoped to the owner (if we know it)
  if (owner) {
    const scoped = text.match(new RegExp(`/stories/${owner}/(\\d{15,20})`));
    if (scoped) return scoped[1];
  }

  // Generic ID in JSON
  const generic = text.match(/"id"\s*:\s*"(\d{15,20})"/);
  if (generic) return generic[1];

  // Generic path form
  const path = text.match(/\/stories\/[^/]+\/(\d{15,20})/);
  return path ? path[1] : null;
}

function getMediaIdFromDOM() {
  const owner = getStoryOwnerFromURL();

  // 1) URL path (fastest)
  {
    const m = location.pathname.match(/\/stories\/[^/]+\/(\d{15,20})/);
    if (m) return m[1];
  }

  // 2) "Seen by" link (your own stories)
  {
    const seen = document.querySelector('a[href*="/seen_by/"]');
    if (seen?.href) {
      const m = seen.href.match(/\/stories\/[^/]+\/(\d{15,20})/);
      if (m) return m[1];
    }
  }

  // 3) <link rel="alternate"> variants
  {
    const links = document.querySelectorAll('link[rel="alternate"][href*="/stories/"]');
    for (const l of links) {
      const href = l.getAttribute('href') || '';
      if (owner && !href.includes(`/stories/${owner}/`)) continue;
      const m = href.match(/\/stories\/[^/]+\/(\d{15,20})/);
      if (m) return m[1];
    }
  }

  // 4) App deep links
  {
    const metas = document.querySelectorAll('meta[property^="al:"][content*="/stories/"]');
    for (const meta of metas) {
      const c = meta.getAttribute('content') || '';
      const m = c.match(/\/stories\/[^/]+\/(\d{15,20})/);
      if (m) return m[1];
    }
  }

  // 5) Base64 bootstrap script (data: URL)
  {
    const scripts = document.querySelectorAll('script[src^="data:text/javascript;base64,"]');
    for (const s of scripts) {
      const src = s.getAttribute('src') || '';
      const idx = src.indexOf(',');
      if (idx === -1) continue;
      try {
        const txt = atob(src.slice(idx + 1));
        const id = matchIdFromText(txt, owner);
        if (id) return id;
      } catch (_) {}
    }
  }

  // 6) Any JSON script payloads (defensive)
  {
    const jsonScripts = document.querySelectorAll(
      'script[type="application/json"],script[type="application/ld+json"]'
    );
    for (const s of jsonScripts) {
      const txt = s.textContent || '';
      const id = matchIdFromText(txt, owner);
      if (id) return id;
    }
  }

  return null; // unknown (we’ll fall back to pathname as key)
}

/** Use this everywhere we build a key for cache/mapping. */
function canonicalKey() {
  const owner = getStoryOwnerFromURL() || 'unknown';
  const mid = getMediaIdFromDOM();
  return mid ? `/stories/${owner}/${mid}/` : location.pathname;
}
```

### How this helps your pain points

* **First story** when the URL lacks the numeric ID: we now fall back to the **Seen‑by link**, **rel=alternate**, **deep‑link metas**, and **the base64 bootstrap**. That gives us the media ID very early, so caching and the “new viewer” bookkeeping stay stable.
* **Share links** and single‑story view: rel=alternate/deep‑link metas cover these pages too.
* **Back/forward between stories**: `canonicalKey()` always includes the media ID when it can be found, so we won’t accidentally keep the last story’s cache.

---

## (Optional) a tiny guard so auto‑open re‑fires on a **new** first story

If you’re already calling `canonicalKey()` in your DOM observer, this is usually enough. If not, add a one‑liner where you detect story change:

```js
// When story (mediaId) changes under the same path, allow re‑open
state.openedForKey.delete(canonicalKey());
```

---

## Quick sanity checks

With DevTools open on a story page:

1. Run this in the **Console**:

   ```js
   (function(){
     const o = (location.pathname.match(/\/stories\/([^/]+)/)||[])[1];
     return {
       url: location.pathname.match(/\/stories\/[^/]+\/(\d{15,20})/)?.[1] || null,
       seenBy: document.querySelector('a[href*="/seen_by/"]')?.href || null,
       alt: [...document.querySelectorAll('link[rel="alternate"][href*="/stories/"]')].map(l=>l.href).slice(0,3),
       deep: [...document.querySelectorAll('meta[property^="al:"][content*="/stories/"]')].map(m=>m.content),
       owner: o
     };
   })()
   ```

   You should see at least one place showing the `/stories/<owner>/<ID>/...` string.

2. Click your first story (with no numeric ID in the URL) and confirm `getMediaIdFromDOM()` returns the correct number.

---

If you drop this `getMediaIdFromDOM()` + `canonicalKey()` in and route your cache with the **canonical key**, you’ll stop seeing the “sometimes 25, sometimes 6” behavior when you move between stories or return to the first slide. It also makes the “Seen by N vs loaded M” check reliable, because you’re always counting against the **right** story.
