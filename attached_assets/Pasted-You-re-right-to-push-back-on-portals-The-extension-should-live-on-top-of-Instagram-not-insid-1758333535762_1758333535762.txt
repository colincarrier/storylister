You’re right to push back on “portals.” The extension should live **on top** of Instagram, not inside its dialogs. The symptoms you’re seeing (can’t close IG’s viewer dialog, typing blocked, duplicate rows, flicker, black screen) are exactly what happens when a panel intercepts events or when multiple paginators run at once.

Below is a **tight, production‑ready fix pack** that (a) keeps Storylister fully isolated, (b) stops event conflicts, (c) simplifies pagination, (d) fixes avatars/names, (e) cleans up state on navigation, and (f) keeps your cache so reopening is instant.

---

## What’s causing the issues (brief)

* **Dialog can’t close / navigation blocked**: panel or global listeners are capturing/consuming events; also End‑key dispatch can hit document instead of the dialog’s scroller.
* **Infinite logs / duplicate IG rows**: multiple pagination loops running concurrently after SPA mutations.
* **Profile pics don’t load; names show `undefined`**: viewer payloads arrive in mixed shapes (GraphQL `node/user` vs REST `user`). We weren’t normalizing; on errors we were rendering literal “undefined”.
* **Flicker/black**: repeated re-renders while IG toggles `aria-hidden` + our panel keeps focus; also repeated “mirror to localStorage” writes.
* **Search not typeable**: global key handlers or a parent wrapper with `pointer-events: none` applied incorrectly.

---

## Drop‑in patches (copy/paste)

### 1) `content-backend.js` — **no portal, no global captures, single paginator, clean state**

> Add/replace these parts verbatim.

**A. Expand the `state` and add helpers (near top):**

```js
const state = {
  injected: false,
  currentStoryId: null,
  autoOpenInProgress: false,
  userClosedForStory: null,
  stopPagination: null,         // <- holds cancel function for a running paginator
  viewerStore: new Map(),
  mirrorTimer: null
};

function resetStoryState() {
  state.autoOpenInProgress = false;
  state.userClosedForStory = null;
  if (state.stopPagination) {
    state.stopPagination();
    state.stopPagination = null;
  }
}
```

**B. Make pause() safe (fixes “.catch of undefined”):**

```js
function pauseVideosIfNeeded() {
  if (!Settings.cache.pauseVideos) return;
  document.querySelectorAll('video').forEach(v => {
    try {
      if (!v.paused && !v.dataset.slPaused) {
        v.pause();                // pause() is sync; don't chain .catch
        v.dataset.slPaused = '1';
      }
    } catch (_) { /* ignore */ }
  });
}
```

**C. Single, simple paginator (no key events, no racing):**

```js
function startPagination(scroller, maxMs = 5000) {
  const start = Date.now();
  let stopped = false;

  const tick = () => {
    if (stopped || !document.contains(scroller)) return;
    if (Date.now() - start > maxMs) return;

    // Just scroll to bottom; Instagram will load more.
    scroller.scrollTop = scroller.scrollHeight;

    const nearBottom = scroller.scrollTop + scroller.clientHeight >= scroller.scrollHeight - 10;
    setTimeout(tick, nearBottom ? 500 : 200);
  };

  tick();
  return () => { stopped = true; };
}
```

**D. Safer scroller lookup (only inside the dialog):**

```js
function findScrollableInDialog() {
  const dlg = document.querySelector('[role="dialog"][aria-modal="true"]');
  if (!dlg) return null;
  return dlg.querySelector('[style*="overflow-y"]')
      || dlg.querySelector('[style*="overflow: hidden auto"]')
      || Array.from(dlg.querySelectorAll('div')).find(el => el.scrollHeight > el.clientHeight + 40)
      || dlg;
}
```

**E. Auto‑open that respects the user and never double‑runs:**

```js
function findSeenByButton() {
  const link = document.querySelector('a[href*="/seen_by/"]');
  if (link) return link;
  const buttons = document.querySelectorAll('[role="button"],button');
  return Array.from(buttons).find(el =>
    /^Seen by(\s+[0-9,]+)?$/i.test((el.textContent || '').trim())
  ) || null;
}

function watchDialogCloseOnce() {
  const dlg = document.querySelector('[role="dialog"][aria-modal="true"]');
  if (!dlg || !dlg.parentElement) return;
  const mo = new MutationObserver(() => {
    if (!document.contains(dlg)) {
      state.userClosedForStory = state.currentStoryId; // respect the user’s intent
      mo.disconnect();
    }
  });
  mo.observe(dlg.parentElement, { childList: true });
}

function autoOpenViewers() {
  if (!Settings.cache.autoOpen) return;
  if (state.autoOpenInProgress) return;
  if (state.userClosedForStory === state.currentStoryId) return; // don't re-open if user closed

  const btn = findSeenByButton();
  if (!btn) return;

  state.autoOpenInProgress = true;
  setTimeout(() => {
    try { btn.click(); } catch (_) {}
    setTimeout(() => {
      const scroller = findScrollableInDialog();
      if (scroller) {
        // cancel any previous run
        if (state.stopPagination) state.stopPagination();
        state.stopPagination = startPagination(scroller);
        watchDialogCloseOnce();
      }
      state.autoOpenInProgress = false;
    }, 400);
  }, 100);
}
```

**F. On SPA mutations, ensure only one paginator and clean story transitions:**

```js
const onDOMChange = throttle(async () => {
  const storyId = getCurrentStoryIdFromURL();
  const own = await isOnOwnStory();

  if (!own) {
    window.dispatchEvent(new CustomEvent('storylister:hide_panel'));
    resetStoryState();
    return;
  }

  window.dispatchEvent(new CustomEvent('storylister:show_panel'));
  ensureInjected();
  pauseVideosIfNeeded();

  if (storyId && storyId !== state.currentStoryId) {
    resetStoryState();
    state.currentStoryId = storyId;
    autoOpenViewers();
  }
}, 200);
```

> Keep your existing `window.addEventListener('message', …)` + `mirrorToLocalStorageDebounced()`; they’re good.

> **Do not** add any global `keydown`/`wheel` handlers; if you already added them, remove them unless they’re scoped to `#storylister-right-rail` with a `.closest()` guard.

---

### 2) `injected.js` — **normalize viewer payloads (fixes undefined names/avatars)**

Add a normalizer right before you format and post the viewers:

```js
function normalizeViewer(v, idx) {
  const n = v?.node || v?.user || v; // unify shapes from GraphQL/REST
  const id = String(n?.id ?? n?.pk ?? n?.pk_id ?? idx);
  const username = n?.username || '';
  const full_name = n?.full_name || '';
  const profile_pic_url = n?.profile_pic_url_hd || n?.profile_pic_url || '';

  return {
    id, username, full_name, profile_pic_url,
    is_verified: !!n?.is_verified,
    followed_by_viewer: !!n?.followed_by_viewer,
    follows_viewer: !!n?.follows_viewer,
    originalIndex: idx,
    viewedAt: n?.timestamp || n?.viewed_at || Date.now()
  };
}
```

Then replace the formatting step with:

```js
const formattedViewers = viewers.map((v, idx) => normalizeViewer(v, idx));
```

This stops “undefined” names and gives the best available avatar URL.

---

### 3) `content.css` — **layering + click‑through outside the panel**

```css
/* The container never blocks clicks outside the panel */
#storylister-right-rail {
  position: fixed !important;
  top: 12px !important;
  right: 12px !important;
  width: 380px !important;
  max-width: calc(100vw - 24px) !important;
  max-height: calc(100vh - 24px) !important;
  z-index: 2147483646 !important;  /* below IG dialog which often hits max */
  pointer-events: none !important;  /* let IG receive clicks */
  display: none;
}

/* Only panel catches events */
#storylister-right-rail.active { display: block !important; }
#storylister-right-rail .storylister-panel { pointer-events: auto !important; }

/* Keep IG dialog above dark scrim issues */
[role="dialog"][aria-modal="true"] { z-index: 2147483647 !important; }

@media (max-width: 768px) {
  #storylister-right-rail {
    right: 0 !important;
    width: min(380px, 100vw) !important;
  }
}
```

This solves: **can’t close IG dialog**, **typing blocked**, and **panel never “eats” the page**.

---

### 4) `content.js` — **avatars, safe strings, closeable modals, instantaneous reopen**

**A. Safe string + avatar HTML helpers (call during render):**

```js
function slSafe(s) { return (typeof s === 'string' ? s : '') || ''; }

function slAvatarHTML(url, username) {
  const initial = (slSafe(username)[0] || 'U').toUpperCase();
  const fallback = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='40'%3E%3Crect width='40' height='40' fill='%23e4e4e7'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' fill='%23666' font-size='20'%3E${initial}%3C/text%3E%3C/svg%3E`;

  if (!url) return `<img class="sl-avatar" src="${fallback}" alt="${slSafe(username)}" />`;

  return `<img class="sl-avatar"
              src="${url}"
              referrerpolicy="no-referrer"
              loading="lazy"
              onerror="this.onerror=null; this.src='${fallback}'"
              alt="${slSafe(username)}" />`;
}
```

**B. Keep cache and render instantly on reopen**
No changes needed to your store key (`panel_story_store`). Ensure the panel’s close button only toggles visibility (do **not** clear storage or `state.viewers`). If you currently clear, remove that.

**C. Make Manage Tags / Insights modals closeable**
Add a generic close handler once:

```js
document.addEventListener('click', (e) => {
  const closeBtn = e.target.closest('[data-sl-close]');
  const backdrop = e.target.classList?.contains('sl-backdrop') ? e.target : null;
  if (closeBtn || backdrop) {
    // Hide any Storylister modal
    document.querySelectorAll('.sl-modal.active').forEach(el => el.classList.remove('active'));
  }
}, true);
```

Your modal markup should put `data-sl-close` on the ✕ button and the backdrop should use `class="sl-backdrop"`; both exist in your UI—this let’s users close modals reliably.

**D. Don’t intercept global keys**
If you added any global `keydown` to support pagination, remove it or scope it:

```js
document.addEventListener('keydown', (e) => {
  if (!e.target.closest('#storylister-right-rail')) return; // only inside panel
  // your keyboard shortcuts here…
}, true);
```

---

### 5) Message‑listener error (“return true” with no reply)

That error comes from an `onMessage` that returns `true` but never calls `sendResponse`. In **every** file where you have a listener, do one of these:

```js
// synchronous
chrome.runtime.onMessage.addListener((req, sender, sendResponse) => {
  // …work…
  sendResponse({ ok: true });
  return; // not true
});

// OR truly async
chrome.runtime.onMessage.addListener((req, sender, sendResponse) => {
  (async () => {
    // await work…
    sendResponse({ ok: true });
  })();
  return true; // keep channel open for async
});
```

If you’re unsure which file, search the codebase for `onMessage` and fix each instance. This alone eliminates the “message channel closed” spam and any cascading breakage.

---

## Why this set works

* **Isolation**: `pointer-events: none` on the container plus `pointer-events: auto` on the panel prevents us from ever “sitting in front” of Instagram’s hit‑targets.
* **No event conflict**: we don’t capture global keys/wheel; pagination is a **single** timed scroll scoped to the dialog’s scroller.
* **Resilience**: viewer payloads normalized, so names/avatars render; safe fallbacks prevent flicker.
* **UX**: closing our UI or IG’s dialog never clears your cache; reopening Storylister is instant.
* **Performance**: one paginator, one debounced localStorage mirror, throttled observer—no runaways.

---

## Quick validation checklist (do these once after patch)

1. Hard refresh your story page.
2. **Open your story** → panel appears; IG “Seen by” opens automatically; list populates.
3. Click IG dialog ✕ → it closes. Panel stays. Click our ✕ → panel hides; show again from the toolbar—data is still there.
4. Type in **Search** → input accepts text; results filter.
5. Scroll IG viewer list → no duplicates; no flicker; profile pics show (fallbacks for rare misses).
6. Navigate to another story → panel follows; no blackouts; counts update.
7. Console: no “return true” message‑channel errors; mutation logs are bounded.

If anything above still misbehaves, the likely remaining culprit is a stray global event listener or an unfixed `onMessage` in one of your older modules. Apply the pattern above to those spots and you’ll be set.
