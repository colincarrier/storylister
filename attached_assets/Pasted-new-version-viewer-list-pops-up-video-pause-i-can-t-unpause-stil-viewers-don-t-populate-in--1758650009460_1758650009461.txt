new version
- viewer list pops up, video pause. . i can't unpause stil.
- viewers don't populate in storylister
- still see spining wheel at the bottom of the IG viewer list
- the page eventually failed, see screen shot. This happened on both the first story, where it never populated data, and the second slide where it seemed to load cached data (even though this was a new extension i just uploaded (maybe it's using existing browser DB files?  Otherwise, how's it getting pre-populated content?  Or maybe somehow it grabbed the list faster than I could see it be populaed, but it looked different than before when I could see the users chunk in.  Then it never got to the correct total, so I don't think it was actually looking at and pulling in the from the viewer list.


Refused to execute inline script because it violates the following Content Security Policy directive: "script-src 'self' 'wasm-unsafe-eval' 'inline-speculation-rules' http://localhost:* http://127.0.0.1:* chrome-extension://70c9ef16-c9ea-4d2e-8e10-b34ceb5e7b2e/". Either the 'unsafe-inline' keyword, a hash ('sha256-bcTlmSHFczAN514LA84TAqaVEAL4nUK8nWERa/vhMuY='), or a nonce ('nonce-...') is required to enable inline execution.
Context
https://www.instagram.com/stories/colincarrier/
Stack Trace
content-backend.js:354 (anonymous function)
content-backend.js:373 (MutationObserver.observe.childList)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
(() => {
  'use strict';

  // ==== [A] TOP OF FILE: state + Settings ====
  const DEBUG = false;

  const state = {
    injected: false,
    currentKey: null,          // stable key = location.pathname (works with and w/o numeric id)
    autoOpenInProgress: false,
    openedForKey: new Set(),   // prevent re-opening
    stopPagination: null,
    viewerStore: new Map(),    // Map<storyKey, Map<viewerKey, viewer>>
    mirrorTimer: null,
    idToKey: new Map(),        // Map<mediaId -> storyKey>
  };

  const Settings = {
    // Defaults that should "just work"
    cache: { pro: false, autoOpen: true, pauseVideos: true, accountHandle: null },

    async load() {
      try {
        const data = await new Promise(r => chrome.storage?.sync?.get?.(null, r));
        if (data) Object.assign(this.cache, data);
      } catch (e) {
        // Fallback when extension context gets invalidated
        try {
          const raw = localStorage.getItem('sl_settings');
          if (raw) Object.assign(this.cache, JSON.parse(raw));
        } catch {}
      }
    },

    async save(patch) {
      Object.assign(this.cache, patch);
      try {
        await new Promise(r => chrome.storage?.sync?.set?.(patch, r));
      } catch (e) {
        // Persist anyway
        try { localStorage.setItem('sl_settings', JSON.stringify(this.cache)); } catch {}
      }
    }
  };

  // ==== [B] UTILITIES ====
  function getStorageKey() { return location.pathname; }  // first-story safe

  function findSeenByButton() {
    return document.querySelector('a[href*="/seen_by/"]') ||
           Array.from(document.querySelectorAll('[role="button"],button'))
             .find(el => /^Seen by(\s+[0-9,]+)?$/i.test((el.textContent||'').trim())) || null;
  }

  async function waitForSeenByButton(timeout = 5000, interval = 150) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      const btn = findSeenByButton();
      if (btn) return btn;
      await new Promise(r => setTimeout(r, interval));
    }
    return null;
  }

  function findScrollableInDialog() {
    const dlg = document.querySelector('[role="dialog"][aria-modal="true"]');
    if (!dlg) return null;
    return dlg.querySelector('[style*="overflow-y"]') ||
           dlg.querySelector('[style*="overflow: hidden auto"]') ||
           Array.from(dlg.querySelectorAll('div')).find(el => el.scrollHeight > el.clientHeight + 40) ||
           dlg;
  }

  function getSeenByCount() {
    const link = document.querySelector('a[href*="/seen_by/"]');
    const txt = (link?.textContent || '').trim();
    const m = txt.match(/(\d[\d,]*)/);
    return m ? parseInt(m[1].replace(/,/g, ''), 10) : null;
  }

  function getStoryOwnerFromURL() {
    const m = location.pathname.match(/\/stories\/([^/]+)/);
    return m ? m[1] : null;
  }

  function hasSeenByUI() {
    // "Seen by" only appears on your own stories.
    const scope = document; // keep broad—button often lives in main story surface
    if (scope.querySelector('a[href*="/seen_by/"]')) return true;
    const els = scope.querySelectorAll('button,[role="button"],span,div');
    return Array.from(els).some(el => /^Seen by(\s+[0-9,]+)?$/i.test((el.textContent || '').trim()));
  }

  async function canRunForOwner(owner) {
    const s = Settings.cache;
    if (s.pro) return true;
    if (!s.accountHandle && owner) {
      await Settings.save({ accountHandle: owner });
      return true;
    }
    return s.accountHandle?.toLowerCase() === owner?.toLowerCase();
  }

  async function isOnOwnStory() {
    if (!location.pathname.startsWith('/stories/')) return false;
    if (!hasSeenByUI()) return false; // bulletproof indicator
    const owner = getStoryOwnerFromURL();
    if (!owner) return false;
    return await canRunForOwner(owner);
  }

  // ==== [C] NATURAL PAUSE — pause only while the IG viewers dialog is open ====
  function pauseVideosWhileViewerOpen() {
    if (!Settings.cache.pauseVideos) return;
    const dlgOpen = !!document.querySelector('[role="dialog"][aria-modal="true"]');
    if (!dlgOpen) return; // don't auto-pause when the dialog isn't open

    setTimeout(() => {
      document.querySelectorAll('video').forEach(v => {
        if (v.dataset.userPlayed === '1') return; // respect manual play
        if (!v.paused && !v.dataset.slPaused) {
          try { v.pause(); v.dataset.slPaused = '1'; } catch {}
        }
      });
    }, 1200); // breaths like a human
  }

  function resumeAnyPausedVideos() {
    document.querySelectorAll('video[data-sl-paused="1"]').forEach(v => {
      try { v.play(); } catch {}
      delete v.dataset.slPaused;
    });
  }

  document.addEventListener('play', (e) => {
    if (e.target?.tagName === 'VIDEO') e.target.dataset.userPlayed = '1';
  }, true);

  // ==== [D] PAGINATION — simple + bounded ====
  function startPagination(scroller, maxMs = 6000) {
    const t0 = Date.now();
    let stopped = false;
    const tick = () => {
      if (stopped || !document.contains(scroller)) return;
      if (Date.now() - t0 > maxMs) return;

      const target = getSeenByCount();
      const currentMap = state.viewerStore.get(getStorageKey());
      const loaded = currentMap ? currentMap.size : 0;
      if (target && loaded >= target - 1) return; // allow ±1

      scroller.scrollTop = scroller.scrollHeight;
      const nearBottom = scroller.scrollTop + scroller.clientHeight >= scroller.scrollHeight - 10;
      setTimeout(tick, nearBottom ? 450 : 250);
    };
    tick();
    return () => { stopped = true; };
  }

  // ==== [E] AUTO-OPEN — first story safe ====
  async function autoOpenViewersOnceFor(key) {
    if (!Settings.cache.autoOpen) return;
    if (state.openedForKey.has(key)) return;
    const btn = await waitForSeenByButton(5000);
    if (!btn) return;
    state.openedForKey.add(key);
    try { btn.click(); } catch {}
    setTimeout(() => {
      const scroller = findScrollableInDialog();
      if (scroller) {
        if (state.stopPagination) state.stopPagination();
        state.stopPagination = startPagination(scroller);
      }
    }, 350);
  }

  // ==== [F] MIRROR TO CACHE — key = pathname; write debounced ====
  function mirrorToLocalStorageDebounced(key) {
    if (state.mirrorTimer) return;
    state.mirrorTimer = setTimeout(() => {
      state.mirrorTimer = null;
      const map = state.viewerStore.get(key);
      if (!map || map.size === 0) return;

      const store = JSON.parse(localStorage.getItem('panel_story_store') || '{}');
      store[key] = { viewers: Array.from(map.entries()), fetchedAt: Date.now() };

      // Also store aliases for mediaIds that map to this key (prevents mis-routing on refresh)
      const aliases = {};
      for (const [mid, k] of state.idToKey.entries()) if (k === key) aliases[mid] = k;
      store.__aliases = Object.assign(store.__aliases || {}, aliases);

      localStorage.setItem('panel_story_store', JSON.stringify(store));
      window.dispatchEvent(new CustomEvent('storylister:data_updated', { detail: { storyId: key } }));
    }, 300);
  }

  // ==== [G] MESSAGE BRIDGE — correct routing + dedupe ====
  window.addEventListener('message', (evt) => {
    if (evt.source !== window || evt.origin !== location.origin) return;
    const msg = evt.data;
    if (!msg || msg.type !== 'STORYLISTER_VIEWERS_CHUNK') return;

    const { mediaId, viewers } = msg.data || {};
    if (!mediaId || !Array.isArray(viewers)) return;

    const activeKey = state.currentKey || getStorageKey();
    if (!state.idToKey.has(mediaId)) state.idToKey.set(mediaId, activeKey);
    const key = state.idToKey.get(mediaId);

    if (!state.viewerStore.has(key)) state.viewerStore.set(key, new Map());
    const map = state.viewerStore.get(key);

    viewers.forEach((v, idx) => {
      // dedupe by username (lowercased) or id
      const viewerKey = (v.username ? String(v.username).toLowerCase() : null) || String(v.id || idx);
      const prev = map.get(viewerKey) || {};
      map.set(viewerKey, { ...prev, ...v });
    });

    mirrorToLocalStorageDebounced(key);
  });

  // Define the injected function that will be inlined
  function injectedFunction() {
    'use strict';
    if (window.__storylisterInjected__) return;
    window.__storylisterInjected__ = true;

    const origFetch = window.fetch;
    window.fetch = async function(...args) {
      const res = await origFetch.apply(this, args);

      try {
        const url = String(args?.[0] || '');
        // Only JSON
        const ct = res.headers?.get('content-type') || '';
        if (!/json/i.test(ct)) return res;

        const relevant = url.includes('/api/') || url.includes('/graphql') || /viewer|viewers|story|reel|seen/i.test(url);
        if (!relevant) return res;

        const clone = res.clone();
        clone.json().then(data => {
          if (!data) return;

          // Collect viewers from known shapes
          let viewers = null;
          if (Array.isArray(data.users)) viewers = data.users;
          else if (Array.isArray(data.viewers)) viewers = data.viewers;
          else if (data?.data?.xdt_api__v1__media__story_viewers?.viewers) viewers = data.data.xdt_api__v1__media__story_viewers.viewers;
          else if (data?.data?.media?.story_viewers?.edges) viewers = data.data.media.story_viewers.edges.map(e => e.node || e.user || e);
          else if (data?.data?.xdt_api__v1__stories__viewers__connection__edge?.edges) viewers = data.data.xdt_api__v1__stories__viewers__connection__edge.edges.map(e => e.node || e);

          if (!viewers || viewers.length === 0) return;

          // Media id: prefer payload, then URL id
          const pathId = location.pathname.match(/\/stories\/[^/]+\/(\d+)/)?.[1];
          const graphId = data?.media_id || data?.data?.media?.id || data?.data?.reel?.id;
          const mediaId = String(graphId || pathId || Date.now());

          const normalized = viewers.map((v, idx) => normalizeViewer(v, idx));

          window.postMessage({
            type: 'STORYLISTER_VIEWERS_CHUNK',
            data: {
              mediaId,
              viewers: normalized,
              totalCount: data.user_count || data.total_viewer_count || normalized.length
            }
          }, '*');
        }).catch(() => {});
      } catch {}
      return res;
    };

    // (Optional) XHR backup for older endpoints
    const XHR = window.XMLHttpRequest;
    if (XHR) {
      const P = XHR.prototype, _open = P.open, _send = P.send;
      P.open = function(method, url, ...rest) { this.__slUrl = url; return _open.call(this, method, url, ...rest); };
      P.send = function(...args) {
        const url = this.__slUrl || '';
        if (/story_viewers|list_reel_media_viewer|api\/v1\//.test(url)) {
          this.addEventListener('load', function() {
            try {
              const data = JSON.parse(this.responseText);
              const users = Array.isArray(data?.users) ? data.users : (Array.isArray(data?.viewers) ? data.viewers : null);
              if (!users) return;

              const pathId = location.pathname.match(/\/stories\/[^/]+\/(\d+)/)?.[1];
              const mediaId = String(data.media_id || pathId || Date.now());
              const normalized = users.map((u, idx) => normalizeViewer(u, idx));

              window.postMessage({
                type: 'STORYLISTER_VIEWERS_CHUNK',
                data: { mediaId, viewers: normalized, totalCount: data.user_count || normalized.length }
              }, '*');
            } catch {}
          });
        }
        return _send.apply(this, args);
      };
    }

    function normalizeViewer(v, idx) {
      const u = v?.user || v?.node?.user || v?.node || v;

      // Robust profile pic: accept only absolute http(s) URLs
      let pic = u?.profile_pic_url || u?.profile_pic_url_hd || u?.profile_picture_url || '';
      if (typeof pic !== 'string' || !/^https?:\/\//i.test(pic)) pic = '';

      // Reactions from known shapes; likes -> ❤️
      const reaction =
        v?.reaction?.emoji ||
        v?.story_reaction?.emoji ||
        v?.latest_reaction?.emoji ||
        (v?.has_liked ? '❤️' : null);

      return {
        id: String(u?.id || u?.pk || u?.pk_id || u?.username || idx),
        username: u?.username || '',
        full_name: u?.full_name || u?.fullname || u?.name || '',
        profile_pic_url: pic,
        is_verified: !!(u?.is_verified || u?.blue_verified || u?.is_verified_badge || u?.verified),
        followed_by_viewer: !!(u?.followed_by_viewer || u?.is_following),
        follows_viewer: !!(u?.follows_viewer || u?.is_follower),
        reaction: reaction || null,
        originalIndex: idx,
        viewedAt: v?.timestamp || v?.viewed_at || Date.now()
      };
    }
  }

  // ==== [H] MAIN OBSERVER — first story, inject, pause only when dialog open ====
  const onDOMChange = (() => {
    let lastKey = null;
    return async () => {
      // gate: only on your own story (Seen by must eventually exist)
      const onStories = location.pathname.startsWith('/stories/');
      if (!onStories) {
        window.dispatchEvent(new CustomEvent('storylister:hide_panel'));
        resumeAnyPausedVideos();
        return;
      }

      window.dispatchEvent(new CustomEvent('storylister:show_panel'));
      // if injection fails because context reloaded, we still keep running
      if (!state.injected) {
        try {
          const s = document.createElement('script');
          // inline the payload to avoid getURL() errors on context reload
          s.textContent = (${injectedFunction.toString()})();;
          document.documentElement.appendChild(s);
          s.remove();
          state.injected = true;
        } catch {}
      }

      const key = getStorageKey();
      if (key !== lastKey) {
        // story changed
        if (state.stopPagination) state.stopPagination();
        lastKey = state.currentKey = key;
        autoOpenViewersOnceFor(key);
      }

      // pause only while viewers dialog is open
      pauseVideosWhileViewerOpen();
    };
  })();

  new MutationObserver(() => onDOMChange()).observe(document.documentElement || document.body, { childList: true, subtree: true });
  onDOMChange();

  // Initialize settings
  (async function init() {
    await Settings.load();
  })();
})();
ChatGPT said:
Request for GPT-5 Pro
Reasoned for 11m 20s

Thanks for the crisp screenshots and the stack trace — they make the failure mode obvious.

TL;DR of what’s breaking right now

No viewers on the first story = our injection method was changed to an inline script. Instagram’s CSP blocks inline scripts, so injected.js never runs → no fetch/XHR interception → “Waiting for viewers…”.

You can see this in your console: “Refused to execute inline script … violates CSP …”.

Video keeps pausing = we still pause while the dialog is not open, and do it repeatedly.

Over‑/under‑count & stale data = viewer chunks can arrive while you’re navigating; without mapping mediaId → story key, a chunk for story A is counted in story B. Also our cache merging is too light.

Console flood/ DNS looking errors = previously caused by malformed avatar URLs getting retried like crazy. We must only accept absolute http(s) profile pics and always fallback.

Settings “context invalidated” = happens during extension reloads. We need a localStorage fallback and defensive calls.

Surgical fixes (drop‑in patches)

Below are targeted edits only. They address the CSP block, first‑story capture, pausing, misrouted chunks, caching, and reactions. They’re short and won’t overcomplicate what’s already working.

1) content-backend.js — inject via src (not inline), with handshake + retry
// Put near top
const DEBUG = false;
let injectCheckTimer = null;

// Listen for injected “hello” so we know hooks are live
window.addEventListener('message', (evt) => {
  if (evt.source !== window || evt.origin !== location.origin) return;
  if (evt.data?.type === 'STORYLISTER_HELLO') {
    state.injected = true;
    if (injectCheckTimer) { clearTimeout(injectCheckTimer); injectCheckTimer = null; }
    if (DEBUG) console.info('[SL] injected.js alive');
  }
});

function ensureInjected() {
  if (state.injected) return;

  try {
    const url = (typeof chrome !== 'undefined' && chrome.runtime?.getURL)
      ? chrome.runtime.getURL('injected.js')
      : null;

    if (!url) {
      // extension may be reloading; retry gently
      if (DEBUG) console.warn('[SL] runtime.getURL unavailable; retrying…');
      setTimeout(ensureInjected, 800);
      return;
    }

    // Avoid double-inject
    if (document.querySelector('script[data-storylister-injected="1"]')) {
      state.injected = true;
      return;
    }

    const s = document.createElement('script');
    s.src = url;
    s.dataset.storylisterInjected = '1';
    s.onload = () => s.remove();
    s.onerror = () => { if (DEBUG) console.error('[SL] injected.js load failed'); };
    (document.head || document.documentElement).appendChild(s);

    // If we don't hear back in 1.5s, try again
    injectCheckTimer = setTimeout(() => {
      if (!state.injected) ensureInjected();
    }, 1500);
  } catch (e) {
    if (DEBUG) console.error('[SL] ensureInjected error', e);
    setTimeout(ensureInjected, 1000);
  }
}


Why: avoids CSP inline block and the “getURL undefined” race on hot‑reloads.

2) First story: wait for the button, open once, then paginate

Replace your auto‑open with:

async function waitForSeenByButton(timeout = 5000, interval = 150) {
  const t0 = Date.now();
  while (Date.now() - t0 < timeout) {
    const link = document.querySelector('a[href*="/seen_by/"]');
    if (link) return link;
    const btn = Array.from(document.querySelectorAll('[role="button"],button'))
      .find(el => /^Seen by(\s+[0-9,]+)?$/i.test((el.textContent||'').trim()));
    if (btn) return btn;
    await new Promise(r => setTimeout(r, interval));
  }
  return null;
}

async function autoOpenViewersOnceFor(key) {
  if (!Settings.cache.autoOpen) return;
  if (state.openedForKey.has(key)) return;

  // Make sure hooks are live before opening
  ensureInjected();

  const btn = await waitForSeenByButton(6000);
  if (!btn) return;

  state.openedForKey.add(key);
  try { btn.click(); } catch {}

  setTimeout(() => {
    const scroller = findScrollableInDialog();
    if (scroller) {
      if (state.stopPagination) state.stopPagination();
      state.stopPagination = startPagination(scroller);
    }
  }, 350);
}

3) Pause only while the IG dialog is open (and never fight the user)
function pauseVideosWhileViewerOpen() {
  if (!Settings.cache.pauseVideos) return;
  const dlgOpen = !!document.querySelector('[role="dialog"][aria-modal="true"]');
  if (!dlgOpen) return;

  setTimeout(() => {
    document.querySelectorAll('video').forEach(v => {
      if (v.dataset.userPlayed === '1') return; // user intent wins
      if (!v.paused && !v.dataset.slPaused) {
        try { v.pause(); v.dataset.slPaused = '1'; } catch {}
      }
    });
  }, 1200);
}

document.addEventListener('play', (e) => {
  if (e.target?.tagName === 'VIDEO') e.target.dataset.userPlayed = '1';
}, true);


Call once from your observer (don’t loop):

// inside onDOMChange, after ensureInjected() / autoOpenViewersOnceFor()
pauseVideosWhileViewerOpen();

4) Route chunks to the right story and dedupe by username
// keep map<mediaId -> storyKey>
state.idToKey = new Map();

window.addEventListener('message', (evt) => {
  if (evt.source !== window || evt.origin !== location.origin) return;
  const msg = evt.data;
  if (!msg || msg.type !== 'STORYLISTER_VIEWERS_CHUNK') return;

  const { mediaId, viewers } = msg.data || {};
  if (!mediaId || !Array.isArray(viewers)) return;

  const activeKey = state.currentKey || getStorageKey();
  if (!state.idToKey.has(mediaId)) state.idToKey.set(mediaId, activeKey);
  const key = state.idToKey.get(mediaId);

  if (!state.viewerStore.has(key)) state.viewerStore.set(key, new Map());
  const map = state.viewerStore.get(key);

  viewers.forEach((v, idx) => {
    const k = (v.username ? v.username.toLowerCase() : null) || String(v.id || idx);
    map.set(k, { ...(map.get(k) || {}), ...v });  // merge so “new” flags are possible
  });

  mirrorToLocalStorageDebounced(key);
});

5) Pagination: simple, bounded, and stop near the target
function getSeenByCount() {
  const a = document.querySelector('a[href*="/seen_by/"]');
  const m = (a?.textContent || '').match(/(\d[\d,]*)/);
  return m ? parseInt(m[1].replace(/,/g, ''), 10) : null;
}

function startPagination(scroller, maxMs = 6000) {
  const t0 = Date.now();
  let stopped = false;
  const tick = () => {
    if (stopped || !document.contains(scroller)) return;
    if (Date.now() - t0 > maxMs) return;

    const target = getSeenByCount();
    const loaded = state.viewerStore.get(getStorageKey())?.size || 0;
    if (target && loaded >= target - 1) return;

    scroller.scrollTop = scroller.scrollHeight;
    const nearBottom = scroller.scrollTop + scroller.clientHeight >= scroller.scrollHeight - 10;
    setTimeout(tick, nearBottom ? 450 : 250);
  };
  tick();
  return () => { stopped = true; };
}

6) Cache: use one stable key and merge (so refresh doesn’t recount)
function getStorageKey() { return location.pathname; } // works with/without numeric id

function mirrorToLocalStorageDebounced(key) {
  if (state.mirrorTimer) return;
  state.mirrorTimer = setTimeout(() => {
    state.mirrorTimer = null;

    const map = state.viewerStore.get(key);
    if (!map || map.size === 0) return;

    const store = JSON.parse(localStorage.getItem('panel_story_store') || '{}');
    const existing = new Map((store[key]?.viewers || []));
    // merge
    for (const [k, v] of map) existing.set(k, { ...(existing.get(k) || {}), ...v });

    store[key] = { viewers: Array.from(existing.entries()), fetchedAt: Date.now() };

    // also store mediaId aliases so later refreshes can resolve
    store.__aliases = store.__aliases || {};
    for (const [mid, k2] of state.idToKey) if (k2 === key) store.__aliases[mid] = k2;

    localStorage.setItem('panel_story_store', JSON.stringify(store));
    window.dispatchEvent(new CustomEvent('storylister:data_updated', { detail: { storyId: key } }));
  }, 300);
}


UI side (content.js): on storylister:show_panel / storylister:data_updated, load from that same key (location.pathname) and merge into the in‑memory list so existing items keep their tags and only newcomers get a “New” badge.

7) injected.js — hello ping, robust avatar, reactions

At the top:

(() => {
  'use strict';
  if (window.__storylisterInjected__) return;
  window.__storylisterInjected__ = true;

  // Let content script know we’re alive
  try { window.postMessage({ type: 'STORYLISTER_HELLO' }, '*'); } catch {}


Inside your normalizeViewer function:

// Accept only absolute http(s) avatars; otherwise leave empty
let pic = u?.profile_pic_url || u?.profile_pic_url_hd || u?.profile_picture_url || '';
if (typeof pic !== 'string' || !/^https?:\/\//i.test(pic)) pic = '';

// Extract lightweight reactions only from existing payloads (no new calls)
const reaction =
  v?.reaction?.emoji ||
  v?.story_reaction?.emoji ||
  v?.latest_reaction?.emoji ||
  (v?.has_liked ? '❤️' : null);

return {
  // …
  profile_pic_url: pic,
  reaction: reaction || null,
  // …
};


This prevents malformed URLs from causing the crazy DNS resolve storms.

8) Settings fallbacks (stops the “context invalidated” warnings)
const Settings = {
  cache: { pro: false, autoOpen: true, pauseVideos: true, accountHandle: null },
  async load() {
    try {
      const data = await new Promise(r => chrome.storage?.sync?.get?.(null, r));
      if (data) Object.assign(this.cache, data);
    } catch (e) {
      try { Object.assign(this.cache, JSON.parse(localStorage.getItem('sl_settings') || '{}')); } catch {}
    }
  },
  async save(patch) {
    Object.assign(this.cache, patch);
    try { await new Promise(r => chrome.storage?.sync?.set?.(patch, r)); }
    catch { try { localStorage.setItem('sl_settings', JSON.stringify(this.cache)); } catch {} }
  }
};

9) UI: add the “❤️ Reacts” filter (one small addition)

In your filter row (where you render Following / Followers / Non‑followers), add a leftmost button:

<button id="sl-filter-reacts" class="sl-chip">❤️ Reacts</button>


And the filtering logic:

// Example
let showReactsOnly = false;
document.getElementById('sl-filter-reacts')?.addEventListener('click', () => {
  showReactsOnly = !showReactsOnly;
  render();
});

function render() {
  const data = currentViewersArray(); // however you read from store
  const filtered = showReactsOnly ? data.filter(v => !!v.reaction) : data;
  // …render as you already do…
}

Why this will fix what you’re seeing

First story now loads: we wait for the button, we inject via src (CSP‑safe), and we open/paginate only once.

Viewers flow into the panel immediately: injected.js actually runs, so the fetch/XHR hooks catch the viewer chunks.

No more auto‑pause fight: we pause only while the IG dialog is open, and we honor user play.

Counts are stable: each mediaId is mapped to the current pathname key; chunks can’t drift across stories.

Cache survives refresh: we store under location.pathname and merge, so refreshing doesn’t recount; newcomers can be flagged “New”.

No CDN storms: avatars are validated and fall back cleanly; no malformed hostnames means no DNS floods.

Settings just work even during hot reloads, thanks to localStorage fallback.

Quick test plan (2 minutes)

(One time) In DevTools Console:
localStorage.removeItem('panel_story_store')

Reload the Instagram tab.

Click your story (first slide — no numeric ID).

Panel shows, IG dialog auto‑opens after a beat.

The panel starts filling with viewers.

Click to play the video while the dialog is open. It should play; we won’t re‑pause it.

Navigate to next story and back — counts stay correct, panel doesn’t rebuild from scratch.

Click Story to Story Insights — first story appears with correct totals.

Toggle ❤️ Reacts — list reduces to only users who reacted/liked.

One more note on the console spam

Those ERR_NAME_NOT_RESOLVED rows were a side‑effect of bad avatar URLs being retried. The validation in normalizeViewer() plus onerror fallbacks on your <img> in the panel keep that quiet.

If you want, send the current content-backend.js and injected.js you’re running — some earlier uploads look expired on my side, so I can’t diff your exact copy. I wrote these patches to be paste‑in replacements around the areas you already have; you shouldn’t need to restructure anything else.