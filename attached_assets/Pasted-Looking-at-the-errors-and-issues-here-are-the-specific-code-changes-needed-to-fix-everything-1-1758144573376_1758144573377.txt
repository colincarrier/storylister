Looking at the errors and issues, here are the specific code changes needed to fix everything:

## 1. **Fix appendChild and DOM Timing Issues** (`chrome-extension/content.js`)

Replace the initialization section (around line 1560-1580) with:

```javascript
// Initialize when DOM is ready
async function initialize() {
  console.log('[Storylister] Extension initializing...');
  
  // Wait for DOM to be fully ready
  if (document.readyState === 'loading') {
    await new Promise(resolve => {
      document.addEventListener('DOMContentLoaded', resolve);
    });
  }
  
  // Ensure body exists before any DOM operations
  if (!document.body) {
    console.error('[Storylister] Body not found, retrying...');
    setTimeout(initialize, 100);
    return;
  }
  
  // Load account-specific data
  currentUsername = detectActiveUsername();
  const settings = await loadSettingsSync();
  await loadTaggedUsers();
  
  // Inject styles safely
  injectStyles();
  
  // Check if we should show the panel
  checkForStories();
  
  // Request initial data
  window.dispatchEvent(new CustomEvent('storylister:request_data'));
}

// Start initialization with retry logic
initialize();
```

## 2. **Fix Sorting with Original Order** (`chrome-extension/content.js`)

Replace the filtering section (around line 140-160):

```javascript
// State for filters
let currentFilters = {
  query: '',
  type: 'all',
  sort: 'recent', // recent (newest), oldest, original
  showTagged: false
};

// In getFilteredViewers function, replace sorting logic:
function getFilteredViewers() {
  let filteredViewers = Array.from(viewers.values());

  // Apply filters...
  
  // Apply sorting
  switch (currentFilters.sort) {
    case 'oldest':
      filteredViewers.sort((a, b) => (a.viewedAt || 0) - (b.viewedAt || 0));
      break;
    case 'original':
      // Preserve Instagram's original order
      filteredViewers.sort((a, b) => (a.originalIndex || 0) - (b.originalIndex || 0));
      break;
    case 'recent':
    default:
      filteredViewers.sort((a, b) => (b.viewedAt || 0) - (a.viewedAt || 0));
      break;
  }

  return filteredViewers;
}
```

## 3. **Fix Viewer Data Processing with Timestamps** (`chrome-extension/content.js`)

Replace loadViewersFromStorage (around line 330):

```javascript
function loadViewersFromStorage() {
  try {
    const storyStore = localStorage.getItem('panel_story_store');
    if (!storyStore) return;
    
    const parsed = JSON.parse(storyStore);
    const urlMatch = location.pathname.match(/\/stories\/[^\/]+\/(\d+)/);
    const currentStoryId = urlMatch ? urlMatch[1] : Object.keys(parsed)[0];
    
    if (!currentStoryId || !parsed[currentStoryId]) return;
    
    currentStory = currentStoryId;
    const storyData = parsed[currentStoryId];
    
    viewers.clear();
    
    if (storyData.viewers && storyData.viewers.length > 0) {
      storyData.viewers.forEach(([id, viewer], index) => {
        const processedViewer = {
          id: viewer.id || id,
          username: viewer.username || '',
          displayName: viewer.full_name || viewer.displayName || viewer.username || '',
          profilePic: viewer.profile_pic_url || `https://ui-avatars.com/api/?name=${viewer.username}`,
          isVerified: viewer.is_verified || false,
          isFollower: viewer.followed_by_viewer || false,
          isFollowing: viewer.follows_viewer || false,
          isTagged: taggedUsers.has(viewer.username),
          isNew: viewer.isNew || false,
          reaction: viewer.reaction || null,
          originalIndex: viewer.originalIndex || index, // Preserve order
          viewedAt: viewer.timestamp || viewer.viewedAt || (Date.now() - (index * 1000))
        };
        
        viewers.set(viewer.username, processedViewer);
      });
      
      storyMeta.domTotal = storyData.domTotal || storyData.viewers.length;
      storyMeta.collectedCount = storyData.viewers.length;
    }
    
    updateViewerList();
  } catch (e) {
    console.error('[Storylister] Error loading viewers:', e);
  }
}
```

## 4. **Fix Event Listeners** (`chrome-extension/content.js`)

Replace the setupEventListeners function (around line 1100):

```javascript
function setupEventListeners() {
  // Ensure elements exist before adding listeners
  const ensureElement = (id, handler) => {
    const element = document.getElementById(id);
    if (element) {
      element.addEventListener('click', handler);
      return true;
    }
    console.warn(`[Storylister] Element #${id} not found`);
    return false;
  };
  
  // Close button
  ensureElement('sl-close', hideRightRail);
  
  // Sort toggle - now with 3 options
  ensureElement('sl-sort', (e) => {
    const sorts = ['recent', 'oldest', 'original'];
    const labels = {
      'recent': '↓ Newest',
      'oldest': '↑ Oldest',
      'original': '📝 Original'
    };
    
    const currentIndex = sorts.indexOf(currentFilters.sort);
    currentFilters.sort = sorts[(currentIndex + 1) % 3];
    e.target.textContent = labels[currentFilters.sort];
    updateViewerList();
  });
  
  // Manage Tags - ensure modal shows
  ensureElement('sl-manage-tags', () => {
    console.log('[Storylister] Opening tags modal');
    showManageTagsModal();
  });
  
  // Story Insights - ensure modal shows
  ensureElement('sl-insights', () => {
    console.log('[Storylister] Opening insights modal');
    showStoryInsights();
  });
  
  // Export
  ensureElement('sl-export', exportData);
  
  // Search
  const searchInput = document.getElementById('sl-search');
  if (searchInput) {
    searchInput.addEventListener('input', (e) => {
      currentFilters.query = e.target.value;
      updateViewerList();
    });
  }
  
  // Filter buttons
  document.querySelectorAll('[data-filter-type]').forEach(btn => {
    btn.addEventListener('click', (e) => {
      document.querySelectorAll('[data-filter-type]').forEach(b => {
        b.classList.remove('active');
      });
      e.currentTarget.classList.add('active');
      currentFilters.type = e.currentTarget.dataset.filterType;
      updateViewerList();
    });
  });
}
```

## 5. **Fix Auto-Open** (`chrome-extension/content-backend.js`)

Replace the autoOpenIfAllowed function:

```javascript
async function autoOpenIfAllowed() {
  if (!Settings.cache.autoOpen) return;
  if (!isOwnStoryView()) return;
  
  // Wait for Instagram UI to fully load
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Multiple selectors for "Seen by" element
  const seenByElement = 
    document.querySelector('a[href*="/seen_by/"]') ||
    document.querySelector('[aria-label*="Viewers"]') ||
    Array.from(document.querySelectorAll('span, div')).find(el => {
      const text = el.textContent?.trim() || '';
      return /^Seen by( \d+)?$/i.test(text);
    });
  
  if (!seenByElement) {
    console.log('[Storylister] Seen by element not found');
    return;
  }
  
  // Find clickable parent
  const clickTarget = seenByElement.closest('[role="button"], a, [tabindex="0"]') || 
                     seenByElement.parentElement;
  
  if (clickTarget && !document.querySelector('[aria-label="Viewers"]')) {
    console.log('[Storylister] Clicking seen by element');
    
    // Try multiple click methods
    clickTarget.click();
    
    // Fallback with mouse event
    if (!document.querySelector('[aria-label="Viewers"]')) {
      setTimeout(() => {
        const mouseEvent = new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
          view: window
        });
        clickTarget.dispatchEvent(mouseEvent);
      }, 500);
    }
    
    // Start network injection after click
    setTimeout(() => {
      injectNetworkScriptOnce();
    }, 500);
  }
}
```

## 6. **Fix Modal Display Issues** (`chrome-extension/content.js`)

Make sure the modals are created and shown properly:

```javascript
function showManageTagsModal() {
  let modal = document.getElementById('storylister-tags-modal');
  
  if (!modal) {
    console.log('[Storylister] Creating tags modal');
    modal = createManageTagsModal();
  }
  
  // Populate content
  const listEl = document.getElementById('sl-tags-list');
  if (listEl) {
    if (taggedUsers.size === 0) {
      listEl.innerHTML = '<div style="text-align: center; color: #9ca3af; padding: 20px;">No tagged users yet</div>';
    } else {
      listEl.innerHTML = '';
      taggedUsers.forEach(username => {
        const itemEl = document.createElement('div');
        itemEl.className = 'storylister-tag-item';
        itemEl.innerHTML = `
          <span class="storylister-tag-username">@${username}</span>
          <button class="storylister-tag-remove" data-username="${username}">Remove</button>
        `;
        listEl.appendChild(itemEl);
      });
    }
  }
  
  // Show modal with proper styling
  modal.style.display = 'block';
  setTimeout(() => {
    modal.classList.add('active');
  }, 10);
  
  // Setup close handler
  const closeBtn = document.getElementById('sl-tags-close');
  if (closeBtn) {
    closeBtn.onclick = () => {
      modal.classList.remove('active');
      setTimeout(() => {
        modal.style.display = 'none';
      }, 300);
    };
  }
}

function showStoryInsights() {
  let modal = document.getElementById('storylister-insights-modal');
  
  if (!modal) {
    console.log('[Storylister] Creating insights modal');
    modal = createStoryInsightsModal();
  }
  
  // Calculate and populate insights...
  // (existing logic)
  
  // Show modal properly
  modal.style.display = 'block';
  
  // Setup close handlers
  const closeBtn = document.getElementById('sl-insights-close');
  const overlay = document.getElementById('sl-insights-overlay');
  
  if (closeBtn) {
    closeBtn.onclick = () => modal.style.display = 'none';
  }
  if (overlay) {
    overlay.onclick = () => modal.style.display = 'none';
  }
}
```

## 7. **Preserve Real Timestamps** (`chrome-extension/injected.js`)

Update the parseREST function:

```javascript
function parseREST(json) {
  const viewers = [];
  let totalCount = null;

  if (json?.users && Array.isArray(json.users)) {
    json.users.forEach((user, index) => {
      viewers.push({
        id: user.pk || user.id,
        username: user.username,
        full_name: user.full_name || '',
        profile_pic_url: user.profile_pic_url || '',
        is_verified: !!user.is_verified,
        is_private: !!user.is_private,
        follows_viewer: !!user.friendship_status?.following,
        followed_by_viewer: !!user.friendship_status?.followed_by,
        reaction: user.quick_reaction_emoji || user.reel_reaction || null,
        // Preserve actual timestamp if available, otherwise create descending timestamps
        timestamp: user.timestamp || user.latest_reel_media || (Date.now() - (index * 60000)),
        originalIndex: index // Preserve Instagram's order
      });
    });
  }

  if (json?.user_count !== undefined) {
    totalCount = json.user_count;
  }

  return { viewers, totalCount };
}
```

These changes should fix:
- ✅ appendChild errors with proper DOM checks
- ✅ Auto-popup with better detection and timing
- ✅ Three sort options (newest, oldest, original)
- ✅ Timestamp preservation from Instagram
- ✅ Modal display issues
- ✅ Event handler attachment

The key improvements are better error handling, proper DOM readiness checks, and preserving Instagram's original data order.