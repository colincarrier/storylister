You’re right to roll back to the last *stable* state and make **small, surgical fixes**.
v16 broke because it re‑introduced two things we’ve been avoiding:

* **Inline script injection** → CSP blocks it (`Refused to execute inline script…`) and leaves the page half‑patched.
* **Aggressive, un‑gated observers** → repeated injection attempts + autoplay pause loops = UI hangs.

Below is a **v15 hot‑fix set** that keeps the working parts of v15 and addresses the issues you called out (first‑story detection, occasional under‑count, autoplay pause, reactions, tag button hit‑box, and “sometimes it doesn’t refresh after I return”).

---

## What to keep from v15

* External injection of `injected.js` via `chrome.runtime.getURL(...)` (don’t inline).
* One MutationObserver, throttled.
* “Pause only when IG viewer dialog is open” (never pause while the dialog is closed).
* Storage key based on **pathname**, with **aliases** for the real `mediaId` so refresh/back/forward reuse the same cache.

---

## What **not** to re‑introduce (this is what broke v16)

* ❌ **Inline** payloads like `script.textContent = '('+fn+')()'` (CSP blocks it).
* ❌ Injecting on *every* mutation.
* ❌ Global event captures that stop IG’s own handlers.
* ❌ Re‑pausing videos immediately after the user presses Play.

---

## Minimal patches (drop‑in)

> The snippets below assume your v15 files. Paste/replace in place.
> I kept function names close to yours so you can diff quickly.

### 1) `content-backend.js`

**A. CSP‑safe injection (replace your `ensureInjected()` with this):**

```js
function ensureInjected() {
  if (state.injected) return;
  try {
    if (document.querySelector('script[data-sl-injected="1"]')) {
      state.injected = true;
      return;
    }
    const s = document.createElement('script');
    s.src = chrome.runtime.getURL('injected.js'); // external URL is allowed by IG CSP
    s.async = false;
    s.dataset.slInjected = '1';
    s.onload = () => s.remove();
    (document.head || document.documentElement).appendChild(s);
    state.injected = true;
  } catch (e) {
    console.warn('[Storylister] injection failed', e);
  }
}
```

**B. Stable story key + first‑story fallback**
Use pathname as the canonical cache key, but *also* try to discover the numeric `mediaId` the first time we see a story (so we can alias it and stop under‑counts when you navigate back to it).

```js
function getStoryOwnerFromURL() {
  const m = location.pathname.match(/\/stories\/([^/]+)/);
  return m ? m[1] : null;
}

function pathIdFromURL() {
  return location.pathname.match(/\/stories\/[^/]+\/(\d+)/)?.[1] || null;
}

// Scan <link rel="alternate"> and <a href> for /stories/<owner>/<id>
function findMediaIdInDOM(owner) {
  if (!owner) return null;
  const re = new RegExp(`/stories/${owner}/(\\d{10,})`);
  const candidates = new Set();

  document.querySelectorAll('link[rel="alternate"][href*="/stories/"], a[href*="/stories/"]').forEach(el => {
    const href = el.getAttribute('href') || el.href || '';
    const m = href.match(re);
    if (m) candidates.add(m[1]);
  });

  // Pick a deterministic id (first unseen id, else first)
  const ids = Array.from(candidates);
  if (!ids.length) return null;
  for (const id of ids) if (!state.idToKey?.has(id)) return id;
  return ids[0];
}

// Always safe: pathname is our canonical key
function pathKey() { return location.pathname; }

// Return {pathKey, mediaKey?}
function currentKeys() {
  const owner = getStoryOwnerFromURL();
  const urlId = pathIdFromURL();
  const domId = urlId || findMediaIdInDOM(owner);
  return { path: pathKey(), media: domId ? `/stories/${owner}/${domId}/` : null };
}
```

**C. Map incoming chunks to the *current* story key early (prevents misrouting/over‑count):**

```js
// before using the chunk, remember which story key the mediaId belongs to
function routeMediaId(mediaId) {
  const { path, media } = currentKeys();
  const key = media || path; // prefer numeric, else pathname
  if (!state.idToKey) state.idToKey = new Map();
  if (!state.idToKey.has(mediaId)) state.idToKey.set(mediaId, key);
  return state.idToKey.get(mediaId);
}
```

**D. Message bridge (replace your chunk handler body with this core):**

```js
window.addEventListener('message', (evt) => {
  if (evt.source !== window || evt.origin !== location.origin) return;
  const msg = evt.data;
  if (!msg || msg.type !== 'STORYLISTER_VIEWERS_CHUNK') return;

  const { mediaId, viewers } = msg.data || {};
  if (!mediaId || !Array.isArray(viewers)) return;

  // Route to the correct key even if you navigated mid‑request
  const key = routeMediaId(mediaId);

  if (!state.viewerStore.has(key)) state.viewerStore.set(key, new Map());
  const map = state.viewerStore.get(key);

  // Dedup by username (lowercased) or id, merge reactions and timestamps
  viewers.forEach((v, i) => {
    const k = (v.username ? String(v.username).toLowerCase() : null) || String(v.id || i);
    const prev = map.get(k) || {};
    map.set(k, {
      ...prev,
      ...v,
      reaction: v.reaction || prev.reaction || null,
      viewedAt: v.viewedAt || prev.viewedAt || Date.now()
    });
  });

  mirrorToLocalStorageDebounced(key);
});
```

**E. Mirror to storage under both pathname and media aliases (fixes refresh/back):**

```js
function mirrorToLocalStorageDebounced(key) {
  if (state.mirrorTimer) return;
  state.mirrorTimer = setTimeout(() => {
    state.mirrorTimer = null;
    const map = state.viewerStore.get(key);
    if (!map || map.size === 0) return;

    const store = JSON.parse(localStorage.getItem('panel_story_store') || '{}');
    store[key] = { viewers: Array.from(map.entries()), fetchedAt: Date.now() };

    // also persist mediaId → key aliases (so reload routes correctly)
    store.__aliases = store.__aliases || {};
    for (const [mid, k] of (state.idToKey || new Map()).entries()) {
      if (k === key) store.__aliases[mid] = key;
    }

    localStorage.setItem('panel_story_store', JSON.stringify(store));
    window.dispatchEvent(new CustomEvent('storylister:data_updated', { detail: { storyId: key } }));
  }, 250);
}
```

**F. Auto‑open + pagination (first‑story safe, stop near “Seen by N”):**

```js
async function waitForSeenByButton(timeout = 6000, interval = 120) {
  const t0 = Date.now();
  while (Date.now() - t0 < timeout) {
    const a = document.querySelector('a[href*="/seen_by/"]');
    if (a) return a;
    const btn = Array.from(document.querySelectorAll('[role="button"],button'))
      .find(el => /^Seen by(\s+[0-9,]+)?$/i.test((el.textContent || '').trim()));
    if (btn) return btn;
    await new Promise(r => setTimeout(r, interval));
  }
  return null;
}

function startPagination(scroller, maxMs = 6000) {
  const t0 = Date.now();
  let stopped = false;

  const tick = () => {
    if (stopped || !document.contains(scroller)) return;
    if (Date.now() - t0 > maxMs) return;

    // Stop when we’ve loaded at least the displayed count (±1)
    const target = (() => {
      const link = document.querySelector('a[href*="/seen_by/"]');
      const m = (link?.textContent || '').match(/(\d[\d,]*)/);
      return m ? parseInt(m[1].replace(/,/g, ''), 10) : null;
    })();
    const loaded = (state.viewerStore.get(routeMediaId(pathIdFromURL() || ''))?.size) || 0;
    if (target && loaded >= target - 1) return;

    scroller.scrollTop = scroller.scrollHeight;
    const nearBottom = scroller.scrollTop + scroller.clientHeight >= scroller.scrollHeight - 10;
    setTimeout(tick, nearBottom ? 450 : 250);
  };

  tick();
  return () => { stopped = true; };
}

async function autoOpenViewersOnceFor(key) {
  if (!Settings.cache.autoOpen) return;
  if (state.openedForKey?.has(key)) return;

  const btn = await waitForSeenByButton();
  if (!btn) return;

  state.openedForKey.add(key);
  try { btn.click(); } catch {}
  setTimeout(() => {
    const dlg = document.querySelector('[role="dialog"][aria-modal="true"]');
    const scroller = dlg && (
      dlg.querySelector('[style*="overflow-y"]') ||
      dlg.querySelector('[style*="overflow: hidden auto"]') ||
      Array.from(dlg.querySelectorAll('div')).find(el => el.scrollHeight > el.clientHeight + 40) ||
      dlg
    );
    if (scroller) {
      if (state.stopPagination) state.stopPagination();
      state.stopPagination = startPagination(scroller);
    }
  }, 350);
}
```

**G. Pause only while the IG viewer dialog is open (and never fight the user):**

```js
function pauseVideosWhileViewerOpen() {
  if (!Settings.cache.pauseVideos) return;
  const dlgOpen = !!document.querySelector('[role="dialog"][aria-modal="true"]');
  if (!dlgOpen) return;
  setTimeout(() => {
    document.querySelectorAll('video').forEach(v => {
      if (v.dataset.userPlayed === '1') return; // respect manual play
      if (!v.paused && !v.dataset.slPaused) {
        try { v.pause(); v.dataset.slPaused = '1'; } catch {}
      }
    });
  }, 1000); // human-ish delay
}

// if the user plays a video, never auto-pause that element again
document.addEventListener('play', (e) => {
  if (e.target?.tagName === 'VIDEO') e.target.dataset.userPlayed = '1';
}, true);
```

**H. Observer (gated + throttled, and only shows the panel on *your* story):**

```js
const onDOMChange = (() => {
  let raf = 0, lastKey = null;
  return () => {
    if (raf) cancelAnimationFrame(raf);
    raf = requestAnimationFrame(async () => {
      const onStories = location.pathname.startsWith('/stories/');
      const seenByPresent = !!document.querySelector('a[href*="/seen_by/"]') ||
                            Array.from(document.querySelectorAll('[role="button"],button'))
                              .some(el => /^Seen by(\s+[0-9,]+)?$/i.test((el.textContent || '').trim()));

      if (!onStories || !seenByPresent) {
        window.dispatchEvent(new CustomEvent('storylister:hide_panel'));
        return;
      }

      window.dispatchEvent(new CustomEvent('storylister:show_panel'));
      ensureInjected();               // CSP‑safe
      pauseVideosWhileViewerOpen();   // only while dialog is open

      const keyNow = pathKey();
      if (keyNow !== lastKey) {
        if (state.stopPagination) state.stopPagination();
        lastKey = state.currentKey = keyNow;
        autoOpenViewersOnceFor(keyNow);
      }
    });
  };
})();

new MutationObserver(onDOMChange)
  .observe(document.documentElement || document.body, { childList: true, subtree: true });

onDOMChange();
```

---

### 2) `injected.js`

Make sure we only touch **JSON** responses, derive `mediaId` from payload when present, and carry reactions through.

```js
(() => {
  'use strict';
  if (window.__storylisterInjected__) return;
  window.__storylisterInjected__ = true;

  const origFetch = window.fetch;
  window.fetch = async function(...args) {
    const res = await origFetch.apply(this, args);
    try {
      const url = String(args?.[0] || '');
      const ct = res.headers?.get('content-type') || '';
      if (!/json/i.test(ct)) return res; // ignore CSS/HTML/images

      const relevant = url.includes('/api/') || url.includes('/graphql') || /viewer|viewers|story|reel|seen/i.test(url);
      if (!relevant) return res;

      const clone = res.clone();
      clone.json().then(data => {
        if (!data) return;

        let viewers = null;
        if (Array.isArray(data.users)) viewers = data.users;
        else if (Array.isArray(data.viewers)) viewers = data.viewers;
        else if (data?.data?.xdt_api__v1__media__story_viewers?.viewers) viewers = data.data.xdt_api__v1__media__story_viewers.viewers;
        else if (data?.data?.media?.story_viewers?.edges) viewers = data.data.media.story_viewers.edges.map(e => e.node || e.user || e);
        else if (data?.data?.xdt_api__v1__stories__viewers__connection__edge?.edges) viewers = data.data.xdt_api__v1__stories__viewers__connection__edge.edges.map(e => e.node || e);
        if (!viewers || !viewers.length) return;

        const pathId = location.pathname.match(/\/stories\/[^/]+\/(\d+)/)?.[1];
        const graphId = data.media_id || data?.data?.media?.id || data?.data?.reel?.id;
        const mediaId = String(graphId || pathId || Date.now());

        const normalized = viewers.map((v, i) => {
          const u = v?.user || v?.node?.user || v?.node || v;
          let pic = u?.profile_pic_url || u?.profile_pic_url_hd || u?.profile_picture_url || '';
          if (!/^https?:\/\//i.test(pic||'')) pic = '';
          const reaction = v?.reaction?.emoji || v?.story_reaction?.emoji || v?.latest_reaction?.emoji || (v?.has_liked ? '❤️' : null);
          return {
            id: String(u?.id || u?.pk || u?.pk_id || u?.username || i),
            username: u?.username || '',
            full_name: u?.full_name || u?.fullname || u?.name || '',
            profile_pic_url: pic,
            is_verified: !!(u?.is_verified || u?.verified || u?.blue_verified),
            followed_by_viewer: !!(u?.followed_by_viewer || u?.is_following),
            follows_viewer: !!(u?.follows_viewer || u?.is_follower),
            reaction: reaction || null,
            viewedAt: v?.viewed_at || v?.timestamp || Date.now(),
            originalIndex: i
          };
        });

        window.postMessage({
          type: 'STORYLISTER_VIEWERS_CHUNK',
          data: { mediaId, viewers: normalized, totalCount: data.user_count || data.total_viewer_count || normalized.length }
        }, '*');
      }).catch(() => {});
    } catch {}
    return res;
  };
})();
```

---

### 3) `content.js`

**A. Remove the stray call that throws** (Claude spotted this):

```js
// DELETE these lines if present (they break the first load flow):
// if (data?.viewers) {
//   handleBundledData(data.viewers);
// }
```

**B. Keep raw reaction + boolean for filter, and make the “❤️ Reacts” filter actually work** (in your mapping from storage → UI):

```js
// when building UI rows from stored viewers (loadViewersFromStorage / ui mapping)
viewers.set(viewerKey, {
  id: v.id || v.pk || v.username,
  username: v.username || '',
  displayName: v.full_name || v.displayName || v.username || 'Anonymous',
  profilePic: v.profile_pic_url || v.profilePic || '',
  isVerified: !!v.is_verified,
  isFollower: !!(v.follows_viewer ?? v.is_follower),
  youFollow: !!(v.followed_by_viewer ?? v.is_following),
  reaction: v.reaction || null,
  reacted: !!v.reaction,
  viewedAt: v.viewedAt || v.timestamp || Date.now(),
  originalIndex: Number.isFinite(v.originalIndex) ? v.originalIndex : i,
  isTagged: taggedUsers.has(v.username || v.id)
});
```

```js
// in getFilteredViewers(...)
case 'reacts':
  filteredViewers = filteredViewers.filter(v => v.reacted || v.reaction);
  break;
```

**C. Persist tags per‑owner (they shouldn’t disappear on nav/refresh):**

```js
async function loadTaggedUsers() {
  const owner = (location.pathname.match(/\/stories\/([^/]+)/) || [])[1] || 'default';
  const key = `sl_tags_${owner}`;
  try {
    const raw = localStorage.getItem(key);
    if (raw) { taggedUsers = new Set(JSON.parse(raw)); return; }
  } catch {}
  try {
    const data = await new Promise(r => chrome.storage?.local?.get?.(key, r) || r({}));
    taggedUsers = new Set(data[key] || []);
  } catch { taggedUsers = new Set(); }
}

async function saveTaggedUsers() {
  const owner = (location.pathname.match(/\/stories\/([^/]+)/) || [])[1] || 'default';
  const key = `sl_tags_${owner}`;
  const arr = Array.from(taggedUsers);
  try { localStorage.setItem(key, JSON.stringify(arr)); } catch {}
  try { await new Promise(r => chrome.storage?.local?.set?.({ [key]: arr }, r) || r()); } catch {}
}
```

---

### 4) `content.css` (bigger tag hit‑box)

```css
.storylister-tag {
  cursor: pointer;
  user-select: none;
  position: relative;
}
.storylister-tag * { pointer-events: none; } /* child icon/text don’t steal clicks */
```

---

## Why this fixes the issues you listed

* **First story sometimes didn’t load** → we now discover the numeric `mediaId` from DOM when URL lacks it, and we map incoming chunks to the *current* story key immediately. That prevents missed chunks and mis‑routing during quick navigation.
* **Occasional under‑count** → pagination stops only when `loaded >= "Seen by N" − 1`, and we merge chunks by username/id to avoid double‑counts.
* **Autopause fights you** → we only pause while the **dialog is open**, and once you press Play we never auto‑pause that video again.
* **Reacts weren’t filterable** → reactions are carried end‑to‑end (`injected.js` → storage → UI), and the filter checks both `reaction` and `reacted`.
* **Tag button tap‑target** → full button is clickable; children don’t intercept events.
* **Panel appearing on other people’s stories** → `show_panel` is now gated on the presence of a “Seen by” control (own stories only).

---

## Quick test checklist (v15 + these patches)

1. Open your own story (first slide without numeric id).

   * Panel shows; IG dialog auto‑opens once; video pauses only while dialog is open.\*
2. Scroll the IG dialog – panel count catches up and stops near “Seen by N”.
3. Click Play → story plays; return to dialog → pauses again (only there).
4. Navigate to next story and back → panel shows the *correct* data without re‑counting everything (aliases persisted).
5. Tag a few users → navigate away and refresh → tags persist.
6. “❤️ Reacts” filter shows only viewers with an emoji/like.

---

### One last note about files

A few of your earlier uploads/recordings look expired on my side; if you want line‑by‑line verification against those exact blobs, re‑upload them and I’ll diff precisely. The patch set above doesn’t rely on those and stays within the v15 surface you already have.
