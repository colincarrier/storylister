Great progress—the screenshots show the core data flow is working again on the first story. The problems you’re hitting now are mostly (1) one hard JavaScript error that stops your UI update path, (2) incomplete “reactions” plumbing, (3) tag persistence/UX, and (4) a couple of race guards so the panel doesn’t reset or carry the wrong story’s data.

Below is a **surgical patch set** you can drop in. I’m keeping this tight and pragmatic—no new architecture.

> **Heads‑up:** a few of your earlier uploaded files have expired on my side. If you want me to run a static pass over the exact sources you’re using now, re‑upload them. In the meantime, the edits below are self‑contained and safe to apply.

---

## 0) Kill the runtime error that breaks updates

This one line is crashing the UI update flow whenever `data_updated` fires.

**File:** `content.js`
**Remove entirely (3 lines):**

```js
// ❌ Delete these lines (they reference a function that doesn't exist)
if (data?.viewers) {
  handleBundledData(data.viewers);
}
```

---

## 1) Make the “❤️ Reacts” signal flow end‑to‑end

### 1.1 Injected: preserve reaction + follow flags

(If you already did this, keep it. This is the minimal, robust normalization.)

**File:** `injected.js` – inside your existing `normalizeViewer(v, idx)`:

```js
function normalizeViewer(v, idx) {
  const u = v?.user || v?.node?.user || v?.node || v;

  // Robust profile picture: accept only absolute http(s) URLs
  let pic = u?.profile_pic_url || u?.profile_pic_url_hd || u?.profile_picture_url || '';
  if (typeof pic !== 'string' || !/^https?:\/\//i.test(pic)) pic = '';

  // Reaction from known shapes; IG “like” → ❤️
  const reaction =
    v?.reaction?.emoji ||
    v?.story_reaction?.emoji ||
    v?.latest_reaction?.emoji ||
    (v?.has_liked ? '❤️' : null);

  // Map friendship_status if present (old endpoints)
  const fs = v?.friendship_status;
  const follows_viewer       = (typeof v?.follows_viewer       === 'boolean') ? v.follows_viewer       : !!fs?.following;
  const followed_by_viewer   = (typeof v?.followed_by_viewer   === 'boolean') ? v.followed_by_viewer   : !!fs?.followed_by;

  return {
    id: String(u?.id || u?.pk || u?.pk_id || u?.username || idx),
    username: u?.username || '',
    full_name: u?.full_name || u?.fullname || u?.name || '',
    profile_pic_url: pic,
    is_verified: !!(u?.is_verified || u?.blue_verified || u?.is_verified_badge || u?.verified),
    follows_viewer,
    followed_by_viewer,
    reaction: reaction || null,
    originalIndex: idx,
    viewedAt: v?.timestamp || v?.viewed_at || Date.now()
  };
}
```

### 1.2 UI mapping: keep `reaction`, add `reacted` boolean

**File:** `content.js` – in your storage → UI mapping (where you build the `viewers` map from `store[key].viewers`):

```js
// inside loadViewersFromStorage() (or equivalent hydrate function)
viewers.set(viewerKey, {
  id: v.id || v.pk || v.username,
  username: v.username || '',
  displayName: v.full_name || v.displayName || v.username || 'Anonymous',
  profilePic: v.profile_pic_url || v.profilePic || '',
  isVerified: !!v.is_verified,
  // Followers / Following without hitting any APIs:
  isFollower: !!(v.follows_viewer ?? v.is_follower),
  youFollow:  !!(v.followed_by_viewer ?? v.is_following),
  // ❤️ reactions
  reaction: v.reaction || null,
  reacted: !!v.reaction,
  viewedAt: v.viewedAt || v.timestamp || Date.now(),
  originalIndex: Number.isFinite(v.originalIndex) ? v.originalIndex : i,
  isTagged: taggedUsers.has(v.username || v.id)
});
```

### 1.3 Filter logic for “Reacts”, Followers, Following (no API)

**File:** `content.js` – in `getFilteredViewers()`:

```js
switch (activeFilter) {
  case 'reacts':
    filtered = filtered.filter(v => v.reacted || !!v.reaction);
    break;
  case 'followers':
    filtered = filtered.filter(v => v.isFollower === true);
    break;
  case 'following':
    filtered = filtered.filter(v => v.youFollow === true);
    break;
  case 'non-followers':
    filtered = filtered.filter(v => v.isFollower === false);
    break;
  // ... existing cases
}
```

> You mentioned two “Reacts” buttons—keep only the one in the secondary row. If the top-row button is already removed, you’re set.

---

## 2) Tags: persist reliably and make the whole button clickable

### 2.1 Persist tags per owner (fast localStorage + durable chrome.storage)

**File:** `content.js` – replace your tag load/save with:

```js
let taggedUsers = new Set();

function getOwnerFromURL() {
  return location.pathname.match(/\/stories\/([^/]+)/)?.[1] || 'default';
}

async function loadTaggedUsers() {
  const key = `sl_tags_${getOwnerFromURL()}`;
  try {
    const ls = localStorage.getItem(key);
    if (ls) { taggedUsers = new Set(JSON.parse(ls)); return; }
  } catch {}
  try {
    const data = await new Promise(r => chrome.storage?.local?.get?.(key, r) || r({}));
    taggedUsers = new Set(data?.[key] || []);
  } catch {
    taggedUsers = new Set();
  }
}

async function saveTaggedUsers() {
  const key = `sl_tags_${getOwnerFromURL()}`;
  const arr = Array.from(taggedUsers);
  try { localStorage.setItem(key, JSON.stringify(arr)); } catch {}
  try { await new Promise(r => chrome.storage?.local?.set?.({ [key]: arr }, r) || r()); } catch {}
}
```

Call `loadTaggedUsers()` once when you show the panel and whenever the story owner changes. Call `saveTaggedUsers()` whenever the user tags/untags.

### 2.2 Make the entire tag button tappable

**File:** `content.css` – add:

```css
/* Make the whole tag pill clickable, not just the icon */
.storylister-tag {
  cursor: pointer;
  user-select: none;
  position: relative;
}
.storylister-tag * {
  pointer-events: none; /* children don’t steal the click */
}
```

…and ensure your click handler is bound to `.storylister-tag` (the container), not the inner emoji/icon.

---

## 3) Stop carrying the wrong story’s data / fix first‑story

These are “guardrails” that also prevent the blinking/spinner loop.

**File:** `content-backend.js`

* Use **pathname as the key** so first story (no numeric ID) is stable.
* Map **mediaId → pathname** so chunks fetched for story A don’t land in story B if you navigate fast.

Add near the top:

```js
const idToKey = new Map();

function storageKey() {
  return location.pathname; // works for /stories/<user>/ and /stories/<user>/<id>/
}
```

In your message bridge:

```js
window.addEventListener('message', (evt) => {
  if (evt.source !== window || evt.origin !== location.origin) return;
  const msg = evt.data;
  if (!msg || msg.type !== 'STORYLISTER_VIEWERS_CHUNK') return;

  const { mediaId, viewers } = msg.data || {};
  if (!mediaId || !Array.isArray(viewers)) return;

  const activeKey = state.currentKey || storageKey();
  if (!idToKey.has(mediaId)) idToKey.set(mediaId, activeKey);
  const key = idToKey.get(mediaId);

  if (!state.viewerStore.has(key)) state.viewerStore.set(key, new Map());
  const map = state.viewerStore.get(key);

  viewers.forEach((v, idx) => {
    const k = (v.username ? String(v.username).toLowerCase() : null) || String(v.id || idx);
    const prev = map.get(k) || {};
    map.set(k, { ...prev, ...v });
  });

  mirrorToLocalStorageDebounced(key);
});
```

**Auto‑open for the first story** (don’t gate on “Seen by” existing immediately; wait up to a few seconds):

```js
async function waitForSeenByButton(timeout=5000, interval=150) {
  const t0 = Date.now();
  while (Date.now() - t0 < timeout) {
    const btn = document.querySelector('a[href*="/seen_by/"]') ||
      Array.from(document.querySelectorAll('[role="button"],button'))
        .find(el => /^Seen by(\s+[0-9,]+)?$/i.test((el.textContent||'').trim()));
    if (btn) return btn;
    await new Promise(r => setTimeout(r, interval));
  }
  return null;
}

async function autoOpenViewersOnceFor(key) {
  if (!Settings.cache.autoOpen) return;
  if (state.openedForKey?.has?.(key)) return;
  const btn = await waitForSeenByButton();
  if (!btn) return;
  state.openedForKey.add(key);
  try { btn.click(); } catch {}
  setTimeout(() => {
    const scroller = findScrollableInDialog();
    if (scroller) {
      if (state.stopPagination) state.stopPagination();
      state.stopPagination = startPagination(scroller);
    }
  }, 350);
}
```

**Only pause while the IG dialog is open** (so you can play your story when it isn’t):

```js
function pauseVideosWhileViewerOpen() {
  if (!Settings.cache.pauseVideos) return;
  const dlgOpen = !!document.querySelector('[role="dialog"][aria-modal="true"]');
  if (!dlgOpen) return;
  setTimeout(() => {
    document.querySelectorAll('video').forEach(v => {
      if (v.dataset.userPlayed === '1') return;
      if (!v.paused && !v.dataset.slPaused) {
        try { v.pause(); v.dataset.slPaused = '1'; } catch {}
      }
    });
  }, 1200);
}
document.addEventListener('play', (e) => {
  if (e.target?.tagName === 'VIDEO') e.target.dataset.userPlayed = '1';
}, true);
```

**Mirror to cache (key = pathname) and don’t reset UI to “waiting” if we’re already populated for this key:**

```js
function mirrorToLocalStorageDebounced(key) {
  if (state.mirrorTimer) return;
  state.mirrorTimer = setTimeout(() => {
    state.mirrorTimer = null;
    const map = state.viewerStore.get(key);
    if (!map || map.size === 0) return;

    const store = JSON.parse(localStorage.getItem('panel_story_store') || '{}');
    store[key] = { viewers: Array.from(map.entries()), fetchedAt: Date.now() };
    localStorage.setItem('panel_story_store', JSON.stringify(store));
    window.dispatchEvent(new CustomEvent('storylister:data_updated', { detail: { storyId: key } }));
  }, 300);
}
```

…and in your MutationObserver tick:

```js
const key = storageKey();
if (key !== state.currentKey) {
  state.currentKey = key;
  autoOpenViewersOnceFor(key);
}
pauseVideosWhileViewerOpen();
```

> This combination addresses: first story not loading, wrong counts after navigating, and the blinking spinner loop.

---

## 4) Make the extension icon useful on your story

Clicking the browser action should toggle the panel when you’re on your own story (and show settings otherwise).

**File:** `popup.js` – send a toggle message if the active tab is an Instagram stories page:

```js
chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
  const tab = tabs[0];
  if (tab && /instagram\.com\/stories\//.test(tab.url || '')) {
    chrome.tabs.sendMessage(tab.id, { type: 'STORYLISTER_TOGGLE' });
  } else {
    // fall back to showing the settings UI in the popup
    initSettingsUI(); // your existing function
  }
});
```

**File:** `content.js` – listen for the message:

```js
chrome.runtime.onMessage.addListener((req, _sender, sendResponse) => {
  try {
    if (req?.type === 'STORYLISTER_TOGGLE') {
      const panel = document.getElementById('storylister-right-rail');
      const show = !(panel && panel.classList.contains('active'));
      window.dispatchEvent(new CustomEvent(show ? 'storylister:show_panel' : 'storylister:hide_panel'));
      sendResponse({ ok: true });
      return true;
    }
  } catch (e) {
    sendResponse({ ok: false, error: String(e) });
    return true;
  }
});
```

> **Important:** if you return `true` from an `onMessage` listener, you **must** call `sendResponse()`—the pattern above satisfies Chrome’s requirement and gets rid of the “channel closed before a response was received” warning.

---

## 5) Why those “ERR\_NAME\_NOT\_RESOLVED” bursts showed up

That spike of DNS errors was due to invalid profile picture URLs being retried by the browser. The injected normalization above prevents non‑http(s) values from ever reaching the UI, and your `<img>` tags already have a safe `onerror` fallback, so this quiets those bursts.

---

## 6) Quick verification checklist

1. **First story opens + populates:** land on `/stories/<you>/`, panel opens, viewers stream in within \~1–2s.
2. **Reacts filter:** tap **❤️ Reacts** → only rows with a heart/emoji show.
3. **Followers/Following:** those filters reflect `follows_viewer` / `followed_by_viewer` without any extra API.
4. **Tagging:** clicking anywhere on the tag pill toggles; refresh -> tags persist; switch stories -> tags persist per owner.
5. **Play video:** you can play when the IG dialog is closed; it will auto‑pause only while the dialog is open.
6. **Navigate stories quickly:** counts don’t leak across stories; no blinking “waiting…” loop.
7. **Action icon:** on your story, clicking the toolbar icon opens/closes the panel; on other pages, popup shows settings.

---

## What changed vs. Claude’s notes

* I **agree** with Claude’s four fixes (and you were right to flag the undefined function).
* I kept it lean but added two tiny guards you needed in practice:

  * **id→key routing** so chunks never land in the wrong story,
  * **pause only while dialog open** so you can watch the story normally.

If you want me to diff this against your current package line‑by‑line, re‑upload the files and I’ll mark the exact insertion points.
