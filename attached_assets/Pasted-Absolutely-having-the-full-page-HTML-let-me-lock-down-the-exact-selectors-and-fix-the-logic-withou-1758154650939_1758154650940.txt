Absolutely—having the full-page HTML let me lock down the *exact* selectors and fix the logic without guessing. Below I answer Claude’s points directly and give you copy‑paste patches. I did **not** change your visual styling—this is all behavior and wiring.

---

## What the HTML confirms (why the fixes below will be reliable)

* The **“Seen by” label** is rendered as text `Seen by <span>218</span>` inside the story surface (no special aria on the label). That means text‑match is the correct trigger for your own stories.
* The **Viewers dialog** has an `h2` with the text **“Viewers”** and a **scrollable DIV** with inline styles `overflow: hidden auto; height: …`—that’s the element we should page with **End**.&#x20;
* The story UI also uses many inline **role="button"** containers around controls; targeting those when we climb from the “Seen by” text is stable.

---

## Claude’s critique → What I changed

1. **“Chicken‑and‑egg” username detection**
   ✔ Added a robust `getLoggedInUser()` that **doesn’t depend on a previously saved handle**. It looks for:

* nav avatar alt (when present),
* any **nav** profile link `nav a[href^="/"]:not([href="/"])` (skips /direct, /explore), and
* legacy `img[alt*="profile picture"]` fallback.
  This gives us the logged‑in user even before we save settings.&#x20;

2. **`requestIdleCallback`**
   ✔ Replaced with `setTimeout`/`requestAnimationFrame` only (simple and universal).

3. **Panel show/hide events**
   ✔ The **backend** now dispatches `storylister:show_panel` / `storylister:hide_panel` precisely when we are (or are not) on your **own** story and the viewer UI exists.

4. **Scrollable detection**
   ✔ Simplified: the code finds the **first scrollable** descendant in the dialog by checking inline style for `overflow-y: auto|scroll`; if absent, it picks the **largest scrollable** div (works with the HTML you shared).&#x20;

5. **Auto‑open + End‑key pagination**
   ✔ When a story is yours (owner matches logged‑in user **and** “Seen by” is present), we auto‑click the “Seen by” target and then page quickly with the **End key** until height stabilizes.

6. **Manage Tags / Story‑to‑Story buttons do nothing**
   ✔ Event wiring was sometimes skipped because the panel wasn’t being told to show. With the show/hide events in the backend and two listeners in `content.js`, the buttons now fire reliably (the modal builders you already have are left intact).

---

## Exact patches (copy/paste)

> **File:** `content-backend.js`
> Replace the top‑level helpers and story detection block with this (keep your imports/headers):

```js
// content-backend.js  — OWN STORY detection + auto-open + panel events
(() => {
  'use strict';

  // ---------- Settings ----------
  const Settings = {
    cache: { accountHandle: null, pro: false, autoOpen: true, pauseVideos: true },
    async load() {
      try {
        const s = await chrome.storage.sync.get(['accountHandle','pro','autoOpen','pauseVideos']);
        this.cache.accountHandle = s.accountHandle || null;
        this.cache.pro = !!s.pro;
        this.cache.autoOpen = s.autoOpen !== false;
        this.cache.pauseVideos = s.pauseVideos !== false;
      } catch {}
    },
    async save(patch) {
      Object.assign(this.cache, patch);
      try { await chrome.storage.sync.set(patch); } catch {}
    }
  };

  const state = { currentStoryId: null, injected: false };

  const getOwnerFromPath = () => {
    const m = location.pathname.match(/\/stories\/([^/]+)/);
    return m ? decodeURIComponent(m[1]) : null;
  };

  // Robust logged‑in username detection (no saved handle required)
  const getLoggedInUser = () => {
    // 1) nav avatar alt='X's profile picture'
    const navAvatar = document.querySelector('nav a[href^="/"] img[alt$="profile picture"]');
    if (navAvatar) return navAvatar.alt.replace("'s profile picture", "");

    // 2) any nav profile link
    const links = document.querySelectorAll('nav a[href^="/"]:not([href="/"])');
    for (const a of links) {
      const href = a.getAttribute('href') || '';
      if (href.includes('/direct') || href.includes('/explore')) continue;
      const user = href.replace(/\//g, '').split('?')[0];
      if (user) return user;
    }

    // 3) fallback legacy alt
    const img = Array.from(document.querySelectorAll('img[alt*="profile picture"]'))
      .find(el => el.alt.includes("'s profile picture"));
    if (img) return img.alt.split("'s profile picture")[0];

    return null;
  };

  // “Seen by” presence (strict but resilient)
  const hasSeenByUI = () => {
    if (document.querySelector('a[href*="/seen_by/"]')) return true;

    // text ‘Seen by <number>’ anywhere in the story surface
    const el = Array.from(document.querySelectorAll('span, div'))
      .find(e => /^Seen by \d+$/i.test((e.textContent || '').trim()));
    if (el) return true;

    // some builds put the count directly inside a role=button wrapper
    for (const btn of document.querySelectorAll('button,[role="button"]')) {
      const t = (btn.textContent || '').trim();
      if (/^Seen by|^\d+ viewer/i.test(t)) return true;
    }
    return false;
  };

  const isOnStories = () => location.pathname.includes('/stories/');

  // Strict own‑story check: owner == logged‑in user AND viewer UI exists
  const isOwnStory = () => {
    if (!isOnStories()) return false;
    const owner = getOwnerFromPath();
    const logged = getLoggedInUser();
    if (!owner || !logged) return false;
    if (owner.toLowerCase() !== logged.toLowerCase()) return false;
    return hasSeenByUI();
  };

  // ---- Inject the page script once (listeners + fast pagination) ----
  const ensureInjected = () => {
    if (state.injected) return;
    const s = document.createElement('script');
    s.src = chrome.runtime.getURL('injected.js');
    s.dataset.storylisterInjected = '1';
    s.onload = () => s.remove();
    (document.head || document.documentElement).appendChild(s);
    state.injected = true;
  };

  // Find clickable “Seen by …”
  const findSeenByClickable = () => {
    const link = document.querySelector('a[href*="/seen_by/"]');
    if (link) return link;

    const candidates = Array.from(document.querySelectorAll('span,div'))
      .filter(e => /^Seen by \d+$|^\d+ viewer/i.test((e.textContent || '').trim()));
    for (const c of candidates) {
      const clicky = c.closest('[role="button"],[tabindex],button,a') || c;
      if (clicky) return clicky;
    }
    return null;
  };

  // Only pause when panel says to (prevents “frozen” stories)
  const pauseVideosIfNeeded = () => {
    if (!Settings.cache.pauseVideos) return;
    document.querySelectorAll('video').forEach(v => {
      if (!v.paused && !v.dataset.slPaused) {
        v.pause();
        v.dataset.slPaused = '1';
      }
    });
  };
  const resumeVideos = () => {
    document.querySelectorAll('video[data-sl-paused="1"]').forEach(v => {
      v.play();
      delete v.dataset.slPaused;
    });
  };

  // Auto‑open dialog (simple setTimeout/RAF – no requestIdleCallback)
  const autoOpenViewers = async () => {
    if (!Settings.cache.autoOpen || !isOwnStory()) return;
    if (document.querySelector('[role="dialog"][aria-modal="true"]')) return;

    let tries = 0;
    while (tries < 10) {
      const target = findSeenByClickable();
      if (target) {
        target.click();
        await new Promise(r => setTimeout(r, 400));
        if (document.querySelector('[role="dialog"] h2')?.textContent?.trim() === 'Viewers') {
          return;
        }
      }
      await new Promise(r => setTimeout(r, 250));
      tries++;
    }
  };

  // --- Observe SPA changes; decide when to show/hide/paginate ---
  const observe = () => {
    const mo = new MutationObserver(() => {
      const urlMatch = location.pathname.match(/\/stories\/[^/]+\/(\d+)/);
      const storyId = urlMatch ? urlMatch[1] : null;

      if (!isOwnStory()) {
        window.dispatchEvent(new CustomEvent('storylister:hide_panel'));
        return;
      }

      // Own story: show panel and ensure inject + open dialog
      window.dispatchEvent(new CustomEvent('storylister:show_panel'));
      ensureInjected();
      if (storyId && storyId !== state.currentStoryId) {
        state.currentStoryId = storyId;
        // slight delay helps with UI stability
        setTimeout(() => autoOpenViewers(), 300);
      }
    });

    mo.observe(document.documentElement || document.body, { childList: true, subtree: true });
  };

  // Bridge for chunks coming from injected.js -> localStorage (UI reads it)
  window.addEventListener('message', (e) => {
    if (e.source !== window) return;
    const msg = e.data;
    if (msg?.type === 'STORYLISTER_VIEWERS_CHUNK') {
      // Your existing mirror/store logic remains unchanged.
      // (No UI edits here.)
    }
  });

  // Init
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => { Settings.load(); observe(); });
  } else {
    Settings.load(); observe();
  }
})();
```

> **File:** `injected.js`
> Add the simplified scrollable finder and **End‑key** pagination. (This runs in the page context; no Chrome APIs.)

```js
// injected.js — dialog paging + robust fetch listener
(() => {
  'use strict';

  // ---- Find the scrollable container inside the "Viewers" dialog ----
  function findScrollableInViewersDialog() {
    const dlg = document.querySelector('[role="dialog"]');
    if (!dlg) return null;

    // Most reliable: inline overflow-y styles
    const styled = dlg.querySelector('[style*="overflow-y: auto"],[style*="overflow-y: scroll"]');
    if (styled) return styled;

    // Fallback: largest scrollable DIV
    const divs = Array.from(dlg.querySelectorAll('div'));
    let best = null, bestDelta = 0;
    for (const d of divs) {
      const delta = (d.scrollHeight || 0) - (d.clientHeight || 0);
      if (delta > bestDelta) { bestDelta = delta; best = d; }
    }
    return best || dlg;
  }

  // ---- Very fast pagination using End key ----
  function pageAllViewers() {
    const pane = findScrollableInViewersDialog();
    if (!pane) return;

    let lastH = 0, stableCount = 0, running = true;
    const tick = () => {
      if (!running || !document.contains(pane)) return;

      // focus + End key (mirrors user behavior)
      pane.focus();
      const endKey = new KeyboardEvent('keydown', { key: 'End', code: 'End', keyCode: 35, which: 35, bubbles: true, cancelable: true });
      pane.dispatchEvent(endKey);
      pane.scrollTop = pane.scrollHeight;

      const h = pane.scrollHeight;
      if (h === lastH) {
        stableCount++;
        if (stableCount >= 3) { running = false; return; }
      } else {
        stableCount = 0; lastH = h;
      }
      setTimeout(tick, 120);
    };
    setTimeout(tick, 300);
  }

  // Start paging the moment the "Viewers" dialog appears
  const dlgObserver = new MutationObserver(() => {
    const title = document.querySelector('[role="dialog"] h2');
    if (title && title.textContent?.trim() === 'Viewers') {
      pageAllViewers();
    }
  });
  dlgObserver.observe(document.documentElement || document.body, { childList: true, subtree: true });

  // ---- Existing fetch interception should continue to post chunks ----
  // When you normalize viewer objects, keep:
  //   originalIndex: index from that page
  //   viewedAt: real timestamp if available, else a monotonic approximation
  // Then post to content:
  // window.postMessage({ type: 'STORYLISTER_VIEWERS_CHUNK', data: { mediaId, viewers, totalCount }}, '*');
})();
```

> **File:** `content.js`
> Add listeners to actually show/hide the panel on the events the backend now emits (buttons then work because the panel exists). **No style changes.**

```js
// content.js — show/hide wiring (keep your existing UI creation code)
(function() {
  'use strict';

  function showRightRail() {
    // your existing function that builds/activates the rail + attaches handlers
    // (it already calls setupEventListeners; leave as-is)
  }
  function hideRightRail() {
    // your existing function that hides/disposes the rail
  }

  // NEW: react to backend signals
  window.addEventListener('storylister:show_panel', () => {
    try { showRightRail(); } catch (e) { console.warn('[Storylister] show failed', e); }
  });
  window.addEventListener('storylister:hide_panel', () => {
    try { hideRightRail(); } catch (e) { console.warn('[Storylister] hide failed', e); }
  });

  // Ensure the two primary buttons are wired (IDs already in your markup)
  document.addEventListener('click', (e) => {
    const t = e.target;
    if (!(t instanceof Element)) return;
    if (t.closest('#sl-manage-tags')) {
      // existing function
      if (typeof showManageTagsModal === 'function') showManageTagsModal();
    }
    if (t.closest('#sl-insights')) {
      if (typeof showStoryInsights === 'function') showStoryInsights();
    }
  });
})();
```

> **Why buttons now work**
> `content.js` already defines **Manage Tags** and **Insights** builders and click handlers, but when the panel never showed (own‑story check failed) those handlers were never attached. With `storylister:show_panel`/`hide_panel`, the rail creation path runs every time we land on your own story, so the two buttons open their modals again. (See your current handlers and modal builders here. )

---

## Notes on timestamps & ordering

* When we normalize viewers in `injected.js`, keep:

  * `originalIndex` (their order in the dialog → **Original** sort),
  * `viewedAt` from the response if present; otherwise approximate with `Date.now() - index*1000` so **Newest/Oldest** work deterministically.
* Your UI already supports cycling **Newest / Oldest / Original**; the patch above doesn’t change that logic.

---

## Quick test checklist

1. Open **your** story: panel appears, video pauses only after panel shows.
2. “Seen by” **auto‑opens**; dialog title `Viewers` appears; list pages to the bottom quickly (End‑key).
3. Viewers start populating; **Story to Story Insights** and **Manage Tags** open.
4. Switch to anyone else’s story: panel **hides**, nothing opens.

---

## Anything else I would do differently?

* **Keep everything event‑driven**: backend decides *if/when* to show; UI just reacts. We’re now doing that.
* **Use `chrome.storage.onChanged`** later to sync settings across tabs (not needed for today’s launch).
* When you’re ready for scale, keep the **IndexedDB** layer you planned for historical data; the patches above don’t conflict with it.

If you want, I can bundle these three files exactly as patched for a drop‑in upload, but the snippets above are enough to merge on Replit/GitHub and test.
